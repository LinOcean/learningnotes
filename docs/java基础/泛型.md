# 泛型

## 泛型的定义跟作用

- 一般来说，一个类或者方法只能适用于特定的类或者基本数据类型，有局限性。

- 多态可以弥补这种局限。但依然有不足，比如方法参数指定了接口，新创建的类要想适用这个方法，必须要实现这个接口(有时候要实现接口的方法)。

- 泛型(*generic*)：适用于很多类型。通过解耦类或方法与所使用的类型之间的约束，使得类或方法具备最宽泛的表达力。

- 促成泛型出现的最主要的动机之一是为了创建**集合类**。几乎所有程序在运行过程中都会涉及到一组对象，集合成了复用率较高的类库之一

  泛型出现演进：

  ```java
  public class Holder {
      private Automobile a;
      public Holder(Automobile a) {
          this.a = a;
      }
      public Automobile getA() {
          return a;
      }
  }
  class Automobile{}
  ```

  很明显`Holder`的复用性不高。无法持有其他非`Automobile`对象。*java 5*之前:

  ```java
  public class ObjectHolder {
      private Object a;
      public ObjectHolder(Object a) {
          this.a = a;
      }
      public Object get() {
          return a;
      }
      public void set(Object a) {
          this.a = a;
      }
      public static void main(String[] args) {
          ObjectHolder objectHolder = new ObjectHolder(new Automobile());
          Automobile au = (Automobile)objectHolder.get();
          objectHolder.set("Not an Automobile");
          String str = (String)objectHolder.get();
          objectHolder.set(1);
          Integer x  = (Integer)objectHolder.get();
      }
  }
  ```

  这个还是存在问题。取出元素时有可能出现类型转换异常。如果用的是`Object[]`，那么这个`Holder`就可以存储多种类型的数据，添加元素跟取出元素，都不能在编译阶段就发现问题。泛型可以做到。

  ```java
  public class GenericHolder<T> {
      private T a;
      public GenericHolder() {}
      public T get() {return a;}
      public void set(T a) {this.a = a;}
      
      public static void main(String[] args) {
          GenericHolder<Automobile> genericHolder = new GenericHolder<>();
          genericHolder.set(new Automobile());
          Automobile automobile = genericHolder.get();// No cast needed
          // genericHolder.set("Not an Automobile");// Type checked error
      }
  }
  ```

## A Tuple Library  

- 元组(*Tuple*):它是将一组对象直接打包存储于单一对象中。可以从该对象读取其中的元素，但不允许向其中存储新对象(这个概念也称为 *数据传输对象* 或 *信使* )。(可以解决`return` 语句只能返回单个对象，而实际想返回多个对象问题)。

  ```java
  public class Tuple2<A,B> {
      public final A a;
      public final B b;
      public Tuple2(A a1, B b1) {
          this.a = a1;
          this.b = b1;
      }
      public String rep(){return a +","+ b;}
      @Override
      public String toString() {
          return "(" +rep() + ")";
      }
  }
  ```

  上例中，元组的使用程序可以读取 `a` 和 `b` 然后对它们执行任何操作，但无法对 `a` 和 `b` 重新赋值。

  ```java
  public class Tuple3<A,B,C> extends Tuple2<A,B>{
      private final C c;
      public Tuple3(A a, B b, C c) {
          super(a, b);
          this.c = c;
      }
      @Override
      public String rep() {
          return super.rep() + ", " + c;
      }
  }
  public class TupleTest {
      private static Tuple2<String,Integer> getTuple2(){
          return new Tuple2<>("h1",47);
      }
      private static Tuple3<Amphibian,String,Integer> getTuple3(){
          return new Tuple3<>(new Amphibian(),"hi",47);
      }
      public static void main(String[] args) {
          Tuple2<String, Integer> tuple2 = getTuple2();
          // tuple2.a ="there";// Compile error:final
      }
  }
  ```

  有了泛型，你可以很容易地创建元组，令其返回一组任意类型的对象。

## A Stack Class

- 泛型实现内部链式存储机制示例

  ```java
  public class LinkedStack<T> {
      private static class Node<U> {
        U item;
          Node<U> next;
          Node() {
              item = null;
              next = null;
          }
          public Node(U item, Node<U> next) {
              this.item = item;
              this.next = next;
          }
          boolean end(){
              return item == null && next == null;
          }
      }
      private Node<T> top = new Node<>();
      public void push(T item){
          top = new Node<>(item,top);
      }
      public T top(){
          T result = top.item;
          if (!top.end()) {
              top = top.next;
          }
          return result;
      }
       public static void main(String[] args) {
          LinkedStack<String> list = new LinkedStack<>();
          for (String s : "Phasers on stun!".split(" ")) {
              list.push(s);
          }
          String s;
          while ((s=list.pop())!= null) {
              System.out.println(s);
          }
      }
  }
  ```

## RandomList  

- 加入需要一个持有特定类型对象的列表。每次调用它的 `select()` 方法时都随机返回一个元素。如果希望这种列表可以适用于各种类型，就需要使用泛型

  ```java
  public class RandomList<T> extends ArrayList<T> {
      private Random random = new Random(47);
  
      public T select() {
          return get(random.nextInt(size()));
      }
      public static void main(String[] args) {
          RandomList<String> rs = new RandomList<>();
          Arrays.stream("The quick brown fox jumped over the lazy brown dog".split(" "))
                  .forEach(rs::add);
          IntStream.range(0, 11).forEach(i -> System.out.println(rs.select() + ""));
      }
  }
  ```

## Generic Interfaces  

- **生成器**(*generator*)，一种专门负责创建对象的类。是 **工厂方法** 设计模式的一种应用。例如 `java.util.function` 类库中的 `Supplier` 就是一个生成器，调用其 `get()` 获取对象。`get()` 是泛型方法，返回值为类型参数 `T`。

  ```java
  public class Coffee {
      private static long counter = 0;
      private final long id = counter++;
      @Override
      public String toString() {
          return getClass().getSimpleName() + " " + id;
      }
  }
  public class Americano extends Coffee {}
  public class Breve extends Coffee {}
  public class Cappuccino extends Coffee {}
  public class Latte extends Coffee {}
  public class Mocha extends Coffee {}
  ```

  编写一个类，实现 `Supplier` 接口，它能够随机生成不同类型的 `Coffee` 对象：

  ```java
  public class CoffeeSupplier implements Supplier<Coffee>, Iterable<Coffee> {
      private Class<?>[] types = {Latte.class, Mocha.class, Cappuccino.class,
              Americano.class, Breve.class};
      private static Random random = new Random(47);
      public CoffeeSupplier() {
      }
      private int size = 0;
      public CoffeeSupplier(int size) {
          this.size = size;
      }
      @Override
      public Iterator<Coffee> iterator() {
          return new CoffeeIterator();
      }
      @Override
      public Coffee get() {
          try {
              return (Coffee) types[random.nextInt(types.length)].newInstance();
          } catch (InstantiationException | IllegalAccessException e) {
              throw new RuntimeException();
          }
      }
      class CoffeeIterator implements Iterator<Coffee> {
          int count = size;
          @Override
          public boolean hasNext() {
              return count > 0;
          }
          @Override
          public Coffee next() {
              count--;
              return CoffeeSupplier.this.get();
          }
          @Override
          public void remove() {
              throw new UnsupportedOperationException();
          }
      }
      public static void main(String[] args) {
          for(Coffee c : new CoffeeSupplier(5))
              System.out.println(c);
      }
  }
  
  // 输出结果
  Americano 0
  Latte 1
  Americano 2
  Mocha 3
  Mocha 4
  Breve 5
  Americano 6
  Latte 7
  Cappuccino 8
  Cappuccino 9
  ```

- 生成`Fibonacci `数列例子：

  ```java
  public class Fibonacci implements Supplier<Integer> {
      private int count = 0;
      @Override
      public Integer get() {
          return fib(count++);
      }
      private int fib(int n) {
          if ((n < 2)) {
              return 1;
          }
          return fib(n - 2) + fib(n-1);
      }
      public static void main(String[] args) {
          Stream.generate(new Fibonacci())
                  .limit(18).
                  forEach(System.out::println);
      }
  }
  // 输出结果
  1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584
  ```

- 假如我们现在不能修改`Fibonacci`接口(并不是总能拥有源码控制权)，但同时有想`Fibonacci`能够具有迭代功能。这个时候就可以使用**适配器模式**(*Adapter*)。[也就是客户端需要的是接口类型是`Iterable`，但`Fibonacci`不是这接口类型，又想应用到客户端]。下面使用两种方式实现这种模式：委托跟继承。

  ```java
  public class IterableFibonacci implements Iterable<Integer> {
      private int n;
      private Fibonacci fibonacci;
      public IterableFibonacci(int n, Fibonacci fibonacci) {
          this.n = n;
          this.fibonacci = fibonacci;
      }
      @Override
      public Iterator<Integer> iterator() {
          return new Iterator<Integer>() {
              @Override
              public boolean hasNext() {
                  return n > 0;
              }
              @Override
              public Integer next() {
                  n--;
                  return fibonacci.get();
              }
          };
      }
      public static void main(String[] args) {
          Fibonacci fibonacci = new Fibonacci();
          for (Integer i : new IterableFibonacci(18, fibonacci)) {
              System.out.print(i + " ");
          }
      }
  }
  ```

  另一种常见方式为继承：

  ```java
  public class IterableFibonacci extends Fibonacci implements Iterable<Integer> {
      private int n;
      public IterableFibonacci(int count	) { n = count; }
      @Override
      public Iterator<Integer> iterator() {
          return new Iterator<Integer>() {
              @Override
              public boolean hasNext() { return n > 0; }
              @Override
              public Integer next() {
                  n--;
                  return IterableFibonacci.this.get();
              }
              @Override
              public void remove() { // Not implemented
                  throw new UnsupportedOperationException();
              }
          };
      }
      public static void main(String[] args) {
          for(int i : new IterableFibonacci(18))
              System.out.print(i + " ");
      }
  }
  ```


## Generic Methods  

- 类可能是泛型，也可能不是，与他的方法是不是泛型并没有什么关系。

- 泛型方法独立于类。通常来说，“尽可能”使用泛型方法，通常将单个方法泛型化要比将整个类泛型化更清晰易懂。

- 如果方法是`static`的，那么该方法无法使用该类的泛型类参数。如果要使用泛型类型参数，那么该方法不能是`static`

  泛型方法定义示例：

  ```java
  public class GenericMethods {
      public <T> void gMethod(T x){ //将泛型参数列表放置在返回值之前
          System.out.println(x.getClass().getName());
      }
      public static void main(String[] args) {
          GenericMethods gm = new GenericMethods();
          gm.gMethod("");
          gm.gMethod(1);
          gm.gMethod(1.0);
          gm.gMethod(1.0F);
          gm.gMethod('c');
          gm.gMethod(gm);
      }
  }
  ```

- 对于泛型类，在示例化时必须制定泛型参数。而使用泛型方法时通常不需要指定泛型参数，因为编译器会通过**类型推断**找出相应的类型。调用泛型方法看起来跟调用普通方法一样。

- 泛型方法跟可变参数

  ```java
  public class GenericVarargs {
      @SafeVarargs
      public static <T> List<T> makeList(T... args) {
          List<T> result = new ArrayList<>();
          for (T item : args) {
              result.add(item);
          }
          return result;
      }
      public static void main(String[] args) {
          List<String> ls = makeList("A");
          System.out.println(ls);
          ls = makeList("A", "B", "C");
          System.out.println(ls);
          ls = makeList("ABCDEFGHIJK".split(""));
          System.out.println(ls);
      }
  }
  ```

  `@SafeVarargs` 注解保证我们不会对变长参数列表进行任何修改。可以消除编译器的警告。

## 泛型Supplier

- 这是一个可以利用任意类的无参构造方法来实例化该类的 `Supplier` 。为了减少键入，它还包括一个用于生成 `BasicSupplier` 的泛型方法

  ```java
  public class BasicSupplier<T> implements Supplier<T> {
      private Class<T> type;
      private BasicSupplier(Class<T> type) {
          this.type = type;
      }
      @Override
      public T get() {
          // Assumes type is a public class:
          try {
              return type.newInstance();
          } catch (InstantiationException | IllegalAccessException e) {
             throw new RuntimeException();
          }
      }
      // Produce a default Supplier from a type token:
       static <U> Supplier<U> create(Class<U> type){
          return new BasicSupplier<>(type);
      }
  }
  ```

  `create()` 方法提供了 `BasicSupplier.create(MyType.class)`这种较简洁的语法来代替较笨拙的 `new BasicSupplier (MyType.class)`

  ```java
  public class CountedObject {
      private static long counter = 0;
      private final long id = counter++;
      public long id(){
          return id;
      }
      @Override
      public String toString() {
          return "CountedObject " + id;
      }
  }
  public class BasicSupplierDemo {
      public static void main(String[] args) {
          Stream.generate(BasicSupplier.create(CountedObject.class))
                  .limit(5).forEach(System.out::println);
      }
  }
  ```

  泛型方法减少了产生 **Supplier** 对象所需的代码量。 Java 泛型强制传递 **Class** 对象，以便在 `create()` 方法中将其用于类型推断。

## 简化 Tuple 的使用

- 使用类型参数推断和静态导入，我们将把早期的元组重写为更通用的库

  ```java
  public class Tuple {
      public static <A, B> Tuple2<A, B> tuple(A a, B b) {
          return new Tuple2<>(a, b);
      }
      public static <A, B, C> Tuple3<A, B, C> tuple(A a, B b, C c) {
          return new Tuple3<>(a, b, c);
      }
      public static <A, B, C, D> Tuple4<A, B, C, D> tuple(A a, B b, C c, D d) {
          return new Tuple4<>(a, b, c, d);
      }
  }
  public class TupleTest2 {
      static Tuple2<String,Integer> f(){
          return tuple("hi",47);
      }
      static Tuple2 f2() { return tuple("hi", 47); }
      static Tuple3<Amphibian, String, Integer> g() {
          return tuple(new Amphibian(), "hi", 47);
      }
      static Tuple4<Vehicle , Amphibian, String, Integer> h() {
          return tuple(new Vehicle(), new Amphibian(), "hi", 47);
      }
  
      public static void main(String[] args) {
          Tuple2<String, Integer> ttsi = f();
          System.out.println(ttsi);
          System.out.println(f2());
          System.out.println(g());
          System.out.println(h());
      }
  }
  ```

  `f()` 返回一个参数化的 `Tuple 2` 对象，而 `f2()` 返回一个未参数化的 `Tuple2`对象。编译器不会在这里警告 `f2()` ，因为返回值未以参数化方式使用。从某种意义上说，它被“向上转型”为一个未参数化的 `Tuple2` 。 但是，如果尝试将 `f2()` 的结果放入到参数化的 `Tuple2` 中，则编译器将发出警告。

## Set 工具

- 由`Set`表示的数学关系

  ```java
  public class Sets {
      // 并集
      public static <T> Set<T> union(Set<T> a, Set<T> b) {
          // copy its reference into a new HashSet,
          // so the argument Sets are not directory modified
          Set<T> result = new HashSet<>(a);
          result.addAll(b);
          return result;
      }
      // 交集
      public static <T> Set<T> intersection(Set<T> a, Set<T> b) {
          HashSet<T> result = new HashSet<>(a);
          result.retainAll(b);
          return result;
      }
      // 从superset中移除跟subset中相同的元素
      public static <T> Set<T> difference(Set<T> superset, Set<T> subset) {
          HashSet<T> result = new HashSet<>(superset);
          result.removeAll(subset);
          return result;
      }
      //并集中，不在交集中的元素
      public static <T> Set<T> complement(Set<T> a, Set<T> b) {
          return difference(union(a, b), intersection(a, b));
      }
  }
  ```

- 引入`EnumSet`测试该工具类

  ```java
  public enum Watercolors {
      ZINC, LEMON_YELLOW, MEDIUM_YELLOW, DEEP_YELLOW,
      ORANGE, BRILLIANT_RED, CRIMSON, MAGENTA,
      ROSE_MADDER, VIOLET, CERULEAN_BLUE_HUE,
      PHTHALO_BLUE, ULTRAMARINE, COBALT_BLUE_HUE,
      PERMANENT_GREEN, VIRIDIAN_HUE, SAP_GREEN,
      YELLOW_OCHRE, BURNT_SIENNA, RAW_UMBER,
      BURNT_UMBER, PAYNES_GRAY, IVORY_BLACK
  }
  
  import static com.chapter20.generics.g_simplifyingtupleuse.Sets.*;
  import static com.chapter20.generics.g_simplifyingtupleuse.Watercolors.*;
  
  public class WatercolorSets {
      public static void main(String[] args) {
          Set<Watercolors> set1 = EnumSet.range(BRILLIANT_RED, VIRIDIAN_HUE);
          Set<Watercolors> set2 = EnumSet.range(CERULEAN_BLUE_HUE, BURNT_UMBER);
          System.out.println("set1: " + set1);
          System.out.println("set2: " + set2);
          System.out.println(
                  "union(set1, set2): " + union(set1, set2));
          Set<Watercolors> subset = intersection(set1, set2);
          System.out.println(
                  "intersection(set1, set2): " + subset);
          System.out.println("difference(set1, subset): " +
                  difference(set1, subset));
          System.out.println("difference(set2, subset): " +
                  difference(set2, subset));
          System.out.println("complement(set1, set2): " +
                  complement(set1, set2));
      }
  }
  ```

- `Sets.difference()` 方法来展示 **java.util** 包中各种 **Collection** 和 **Map** 类之间的方法差异

  ```java
  public class CollectionMethodDifferences {
      static Set<String> methodSet(Class<?> type) {
          return Arrays.stream(type.getMethods())
                  .map(Method::getName)
                  .collect(Collectors.toCollection(TreeSet::new));
      }
      static void interfaces(Class<?> type) {
          System.out.print("Interface in " + type.getSimpleName() + ": ");
          System.out.println(Arrays.stream(type.getInterfaces())
                  .map(Class::getSimpleName)
                  .collect(Collectors.toList()));
      }
      static Set<String> object = methodSet(Object.class);
      static {
          object.add("clone");
      }
      static void difference(Class<?> superset,Class<?> subset){
          System.out.print(superset.getSimpleName()+
                  " extends " + subset.getSimpleName()+", adds: ");
          Set<String> comp = Sets.difference(methodSet(superset),methodSet(subset));
          comp.removeAll(object);// Ignore 'Object' methods
          System.out.println(comp);
          interfaces(superset);
      }
      public static void main(String[] args) {
          System.out.println("Collection: " + methodSet(Collection.class));
          interfaces(Collection.class);
          difference(Set.class,Collection.class);
          difference(HashSet.class,Set.class);
          difference(LinkedHashSet.class, HashSet.class);
          difference(TreeSet.class, Set.class);
          difference(List.class, Collection.class);
          difference(ArrayList.class, List.class);
          difference(LinkedList.class, List.class);
          difference(Queue.class, Collection.class);
          difference(PriorityQueue.class, Queue.class);
          System.out.println("Map: " + methodSet(Map.class));
          difference(HashMap.class, Map.class);
          difference(LinkedHashMap.class, HashMap.class);
          difference(SortedMap.class, Map.class);
          difference(TreeMap.class, Map.class);
      }
  }
  
  ```

## 构建复杂模型

- **Mode**:简单且安全地构建模型

  ```java
  public class TupleList<A,B,C,D> extends ArrayList<Tuple4<A,B,C,D>> {
      public static void main(String[] args) {
          TupleList<Vehicle, Amphibian,String,Integer> tl  =new TupleList<>();
          tl.add(TupleTest2.h());
          tl.add(TupleTest2.h());
          tl.forEach(System.out::println);
      }
  }
  ```

- 下面是第二个例子。每个类都是组成块，总体包含很多个块。在这里，该模型是一个具有过道，货架和产品的零售商店：

  ```java
  public class Product {
      private final int id;
      private String description;
      private double price;
      public Product(int id, String description, double price) {
          this.id = id;
          this.description = description;
          this.price = price;
          System.out.println(toString());
      }
      @Override
      public String toString() {
          return id + ": " + description +
                  ", price: $" + price;
      }
      public void priceChange(double change) {
          price += change;
      }
      public static Supplier<Product> generator = new Supplier<Product>() {
          private Random rand = new Random(47);
          @Override
          public Product get() {
              return new Product(rand.nextInt(1000), "Test",
                      Math.round(rand.nextDouble() * 1000.0) + 0.99);
          }
      };
  }
  class Shelf extends ArrayList<Product> {
      Shelf(int nProducts) {
          Suppliers.fill(this, Product.generator, nProducts);
      }
  }
  class Aisle extends ArrayList<Shelf> {
      Aisle(int nShelves, int nProducts) {
          for (int i = 0; i < nShelves; i++)
              add(new Shelf(nProducts));
      }
  }
  class CheckoutStand {}
  class Office {}
  public class Suppliers {
      // Create a collection and fill it
      public static <T, C extends Collection<T>> C
      create(Supplier<C> factory, Supplier<T> gen, int n) {
          return Stream.generate(gen).limit(n).collect(factory, C::add, C::addAll);
      }
      // Fill an existing collection
      public static <T, C extends Collection> C fill(C coll, Supplier<T> gen, int n) {
          Stream.generate(gen).limit(n).forEach(coll::add);
          return coll;
      }
      //Use an unbound method reference to produce a more general method
      public static <H, A> H fill(H holder, BiConsumer<H, A> addr, Supplier<A> gen, int n) {
          Stream.generate(gen).limit(n).forEach(a -> addr.accept(holder, a));
          return holder;
      }
  }
  public class Store extends ArrayList<Aisle> {
      private ArrayList<CheckoutStand> checkouts =
              new ArrayList<>();
      private Office office = new Office();
      public Store(int nAisles, int nShelves, int nProducts) {
          for (int i = 0; i < nAisles; i++)
              add(new Aisle(nShelves, nProducts));
      }
  
      @Override
      public String toString() {
          StringBuilder result = new StringBuilder();
          for (Aisle a : this) {
              for (Shelf s : a) {
                  for (Product p : s) {
                      result.append(p);
                      result.append("\n");
                  }
              }
          }
          return result.toString();
      }
      public static void main(String[] args) {
          System.out.println(new Store(5, 4, 3));
      }
  }
  ```

## 泛型擦拭

- `ArrayList.class`才有意义，而`ArrayList<Integer>.class`没有意义  

  ```java
  public class ErasedTypeEquivalence {
      public static void main(String[] args) {
          Class c1 = new ArrayList<String>().getClass();
          Class c2 = new ArrayList<Integer>().getClass();
          System.out.println(c1==c2);
      }
  }
  // output
  true
  ```

  上例的程序认为`ArrayList<String>.class`跟`ArrayList<Integer>.class`是相同的类型。

  ```java
  public class LostInformation {
      public static void main(String[] args) {
          List list = new ArrayList<>();
          HashMap<Frob, Fnorkle> map = new HashMap<>();
          Quark<Fnorkle> quark = new Quark<>();
          Particle<Long, Double> p = new Particle<>();
          System.out.println(Arrays.toString(list.getClass().getTypeParameters()));
          System.out.println(Arrays.toString(map.getClass().getTypeParameters()));
          System.out.println(Arrays.toString(quark.getClass().getTypeParameters()));
          System.out.println(Arrays.toString(p.getClass().getTypeParameters()));
      }
  }
  class Frob {}
  class Fnorkle {}
  class Quark<Q> {}
  class Particle<POSITION, MOMENTUM> {}
  
  // output
  [E]
  [K, V]
  [Q]
  [POSITION, MOMENTUM]
  ```

  根据 JDK 文档，`Class.getTypeParameters()` “返回一个 `TypeVariable `对象数组，表示泛型声明中声明的类型参数...” 。而从输出结果看出，只能看到用作参数占位符的标识符这一没有意义的信息。

- 在泛型代码内部，无法获取任何有关泛型参数类型的信息。无法得知实际的类型参数。Java 泛型是使用擦除实现的。`List<String>`跟`List<Integer>`在运行时是相同类型`List`。

- 擦拭演变：C++方式 到没有边界再到使用边界

  ```c++
  #include <iostream>
  using namespace std;
  
  template<class T> class Manipulator {
      T obj;
  public:
      Manipulator(T x) { obj = x; }
      void manipulate() { obj.f(); }
  };
  
  class HasF {
  public:
      void f() { cout << "HasF::f()" << endl; }
  };
  
  int main() {
      HasF hf;
      Manipulator<HasF> manipulator(hf);
      manipulator.manipulate();
  }
  ```

  如果用***java***实现上述案例：

  ```java
  public class HasF {
      public void f() {
          System.out.println("HasF.f()");
      }
  }
  public class Manipulation {
      public static void main(String[] args) {
          HasF hf = new HasF();
          Manipulator<HasF> manipulator =
                  new Manipulator<>(hf);
          manipulator.manipulate();
      }
  }
  
  class Manipulator<T>{
      private T obj;
      Manipulator(T x) { obj = x; }
      // Error: cannot find symbol: method f():
      public void manipulate(){
          obj.f();
      }
  }
  ```

  很明显，是没法通过编译的。因为擦除，Java 编译器无法将 `manipulate()` 方法必须能调用` obj` 的 `f()` 方法这一需求映射到 `HasF `具有 `f()` 方法这个事实上。解决这个问题，可以使用边界。

  ```java
  class Manipulator2<T extends HasF>{
      private T obj;
    Manipulator(T x) { obj = x; }
      public void manipulate(){
          obj.f();
      }
  }
  ```

  泛型类型参数会擦除到它的第一个边界(可能有多个边界).`Manipulator2`中，`T` 擦除到了 `HasF`，就像在类的声明中用 `HasF` 替换了` T` 一样。那为什么还需要泛型呢?

  ```java
  class Manipulator3 {
      private HasF obj;
      Manipulator3(HasF x) {
          obj = x;
      }
      public void manipulate() {
          obj.f();
      }
  }
  ```

  这提出了很重要的一点:**泛型只有在类型参数比某个具体类型（以及其子类）更加“泛化”——代码能跨多个类工作时才有用**。当然不能简单地认为格式`<T extends HasF>`是 有缺陷的。如如果某个类有一个返回 **T** 的方法，那么泛型就有所帮助

  ```java
  public class ReturnGenericType<T extends HasF> {
      private T obj;
      public ReturnGenericType(T obj) {
          this.obj = obj;
      }
      public T get(){
          return obj;
      }
  }
  ```

- 擦除使得这种向泛型的迁移成为可能，允许非泛型的代码和泛型代码共存。擦除主要的正当理由是从非泛化代码到泛化代码的转变过程，以及在不破坏现有类库的情况下将泛型融入到语言中

- 泛型不能用于显式地引用运行时类型的操作中，例如转型、`instanceof` 操作和 `new`表达式。因为所有关于参数的类型信息都丢失了。使用泛型并不是强制的

  ```java
  public class ErasureAndInheritance {
      public static void main(String[] args) {
          Derived2 derived2 = new Derived2();
          Object obj = derived2.get();
          derived2.set(obj); // Warning hear
      }
  }
  class GenericBase<T>{
      private T element;
      public void set(T arg){
          element = arg;
      }
      public T get(){return element;}
  }
  class Derived1<T> extends GenericBase<T>{}
  class Derived2<T> extends GenericBase{} // No warning
  //class Derived3 extends GenericBase<?> {}
  
  ```

  `Derived2`继承自` GenericBase`，但是没有任何类型参数，编译器没有发出任何警告。直到调用 `set()` 方法时才出现警告。

  当你希望将类型参数不仅仅当作 Object 处理时，就需要付出额外努力来管理边界。

## The Action at the Boundaries  

- 泛型还有一缺陷是竟然可以表示没有意义的事务：

  ```java
  public class ArrayMaker<T> {
      private Class<T> kind;
      public ArrayMaker(Class<T> kind) {
          this.kind = kind;
      }
      public T[] create(int size) {
          @SuppressWarnings("unchecked") T[] result = 
                  (T[]) Array.newInstance(kind, size);
          return result;
      }
  }
  ```

  `Array.newInstance`方法返回`Object`(或者说这里就不应该返回`Object`而应该返回`kind`类型的数组)，强制类型转换后出现警告:`Unchecked cast:'java.lang.Object' to 'T[]'`。这说明，`Array.newInstance`方法并不真正地拥有类型`kind`。(可以使用`@SuppressWarnings("unchecked")`来消除警告，不过该警告应该尽可能小范围使用--Effective java)。

  ```java
  public class Suppliers {
      // Create a collection and fill it
      public static <T, C extends Collection<T>> C
      create(Supplier<C> factory, Supplier<T> gen, int n) {
          return Stream.generate(gen).limit(n).collect(factory, C::add, C::addAll);
      }
      // Fill an existing collection
      public static <T, C extends Collection> C fill(C coll, Supplier<T> gen, int n) {
          Stream.generate(gen).limit(n).forEach(coll::add);
          return coll;
      }
      //Use an unbound method reference to produce a more general method
      public static <H, A> H fill(H holder, BiConsumer<H, A> addr, Supplier<A> gen, int n) {
          Stream.generate(gen).limit(n).forEach(a -> addr.accept(holder, a));
          return holder;
      }
  }
  public class FilledList<T> extends ArrayList<T> {
      FilledList(Supplier<T> gen,int size){
          Suppliers.fill(this,gen,size);
      }
      public FilledList(T t,int size){
          for (int i = 0; i < size; i++) {
              this.add(t);
          }
      }
      public static void main(String[] args) {
          List<String> list = new FilledList<>("Hello", 4);
          System.out.println(list);
          List<Integer> ilist = new FilledList<>(() -> 47, 4);
          System.out.println(ilist);
      }
  }
  ```

  编译器无法得知 `add()` 中的 **T** 的任何信息，但它仍可以在编译期确保你放入 `FilledList`中的对象是 **T** 类型。因此，即使擦除移除了方法或类中的实际类型的信息，编译器仍可以确保方法或类中使用的类型的内部一致性。

- 边界动作

  ```java
  public class SimpleHolder {
      private Object obj;
      public void set(Object obj) {
          this.obj = obj;
      }
      public Object get() {
          return obj;
      }
      public static void main(String[] args) {
          SimpleHolder holder = new SimpleHolder();
          holder.set("Item");
          String s = (String) holder.get();
      }
  }
  ```

  使用***javap -c SimpleHolder***反编译：

  ```java
  public void set(java.lang.Object);
     0: aload_0
     1: aload_1
     2: putfield #2; // Field obj:Object;
     5: return
      
  public java.lang.Object get();
     0: aload_0
     1: getfield #2; // Field obj:Object;
     4: areturn
      
  public static void main(java.lang.String[]);
     0: new #3; // class SimpleHolder
     3: dup
     4: invokespecial #4; // Method "<init>":()V
     7: astore_1
     8: aload_1
     9: ldc #5; // String Item
     11: invokevirtual #6; // Method set:(Object;)V
     14: aload_1
     15: invokevirtual #7; // Method get:()Object;
     18: checkcast #8; // class java/lang/String
     21: astore_2
     22: return
  ```

  在调用 `get()` 时接受检查转型。接下来使用泛型和反编译结果：

  ```java
  public class GenericHolder2<T> {
      private T obj;
      public void set(T obj){
          this.obj = obj;
      }
      public T get(){
          return obj;
      }
      public static void main(String[] args) {
          GenericHolder2<String> holder = new GenericHolder2<>();
          holder.set("item");
          String item = holder.get();
      }
  }
  public void set(java.lang.Object);
     0: aload_0
     1: aload_1
     2: putfield #2; // Field obj:Object;
     5: return
         
  public java.lang.Object get();
     0: aload_0
     1: getfield #2; // Field obj:Object;
     4: areturn
         
  public static void main(java.lang.String[]);
     0: new #3; // class GenericHolder2
     3: dup
     4: invokespecial #4; // Method "<init>":()V
     7: astore_1
     8: aload_1
     9: ldc #5; // String Item
     11: invokevirtual #6; // Method set:(Object;)V
     14: aload_1
     15: invokevirtual #7; // Method get:()Object;
     18: checkcast #8; // class java/lang/String
     21: astore_2
     22: return
  ```

  上面可以看出，使用泛型跟不使用泛型产生的字节码文件都是一样的。使用泛型，调用`get()`方法时，编译器自动插入了类型转换。这个告诉我们，泛型的所有动作发生在边界处——对入参的编译器检查和对返回值的转型。

## 补偿擦拭

- 泛型擦拭问题示例：

  ```java
  public class Erased<T> {
      private final int SIZE = 100;
      public void f(Object arg){
          // error: illegal generic type of instanceof
          if (arg instanceof T) {}
          // error:unexpected type
          T var = new T();
          // error: generic array creation
          T[] array = new T[SIZE];
          // warning: [unchecked] unchecked cast
          T[] arr = (T[])new Object[SIZE];
      }
  }
  ```

- 有一些补偿机制解决上例问题，如`isInstance`补偿`instanceof`

  ```java
  public class ClassTypeCapture<T> {
      Class<T> kind;
      public ClassTypeCapture(Class<T> kind) {
          this.kind = kind;
      }
      public boolean isInstance(Object arg) {
          return kind.isInstance(arg);
      }
      public static void main(String[] args) {
          ClassTypeCapture<Building> btc = new ClassTypeCapture<>(Building.class);
          System.out.println(btc.isInstance(new Building()));
          System.out.println(btc.isInstance(new House()));
          ClassTypeCapture<House> ctt =
                  new ClassTypeCapture<>(House.class);
          System.out.println(ctt.isInstance(new Building()));
          System.out.println(ctt.isInstance((new House())));
      }
  }
  class Building {
  }
  class House extends Building {
  }
  ```

- 补偿 `new T()`:传入一个工厂对象，并使用该对象创建新实例

  ```java
  public class InstantiateGenericType {
      public static void main(String[] args) {
          ClassAsFactory<Employee> fe = new ClassAsFactory<>(Employee.class);
          System.out.println(fe.get());
          ClassAsFactory<Integer> fi =
                  new ClassAsFactory<>(Integer.class);
          try {
              System.out.println(fi.get());
          } catch (Exception e) {
              System.out.println(e.getMessage());
          }
      }
  }
  class Employee {
      @Override
      public String toString() {
          return "Employee";
      }
  }
  class ClassAsFactory<T> implements Supplier<T>{
      private Class<T> kind;
      ClassAsFactory(Class<T> kind) {
          this.kind = kind;
      }
      @Override
      public T get() {
          try {
              return kind.newInstance();
          } catch (InstantiationException|IllegalAccessException e) {
            throw new RuntimeException(e);
          }
      }
  }
  // output
  /**
   * Employee
   * java.lang.InstantiationException: java.lang.Integer
   */
  ```

  由于`Integer`中没有无参构造方法，`ClassAsFactory<Integer> `执行失败。语言创建者不赞成这种方法。他们建议使用显式工厂（**Supplier**）

  ```java
  public class FactoryConstraint {
      public static void main(String[] args) {
          System.out.println(new Foo2<>(new IntegerFactory()));
          System.out.println(new Foo2<>(new Widget.Factory()));
          System.out.println(new Foo2<>(Fudge::new));
      }
  }
  class IntegerFactory implements Supplier<Integer>{
      private int i;
      @Override
      public Integer get() {
          return ++i;
      }
  }
  class Widget{
      private int id;
      public Widget(int id) {
          this.id = id;
      }
      @Override
      public String toString() {
          return "Widget " + id;
      }
      public static class Factory implements Supplier<Widget>{
          private int i = 0;
          @Override
          public Widget get() {
              return new Widget(++i);
          }
      }
  }
  class Fudge{
      private static int count = 1;
      private int n = count++;
      @Override
      public String toString() {
          return "Fudge " + n;
      }
  }
  class Foo2<T>{
      private List<T> x = new ArrayList<>();
      Foo2(Supplier<T> factory) {
          Suppliers.fill(x, factory, 5);
      }
      @Override
      public String toString() {
          return x.toString();
      }
  }
  ```

  `IntegerFactory`本身就是通过实现 `Supplier` 的工厂。 `Widget` 包含一个内部类，它是一个工厂。还要注意，`Fudge`并没有做任何类似于工厂的操作，并且传递 `Fudge::new` 仍然会产生工厂行为，因为编译器将对函数方法 `::new` 的调用转换为对 `get()` 的调用。

- 模板方法模式实现工厂

  ```java
  public abstract class GenericWithCreate<T> {
       final T element;
      public GenericWithCreate() {
          element = create();
      }
      abstract T create();
  }
  class  X{}
  class XCreator extends GenericWithCreate<X>{
      @Override
      X create() {
          return new X();
      }
      void f(){
          System.out.println(element.getClass().getSimpleName());
      }
  }
  public class CreatorGeneric {
      public static void main(String[] args) {
          XCreator xc = new XCreator();
          xc.f();
      }
  }
  ```

- 泛型数组，先看第一个类型转换失败例子:

  创建一个`Object`类型的数组，然后转换成想要类型的数组

  ```java
  public class ArrayOfGeneric {
      static final int SIZE = 100;
      static Generic<Integer>[] gia;
  
      public static void main(String[] args) {
          try {
              gia = (Generic<Integer>[]) new Object[SIZE];
          } catch (ClassCastException e) {
              System.out.println(e.getMessage());
          }
          // Runtime type is the raw (erased) type:
          gia = (Generic<Integer>[]) new Generic[SIZE];
          System.out.println(gia.getClass().getSimpleName());
          gia[0] = new Generic<>();
          // gia[1] = new Object(); // Compile-time error
          //gia[2] = new Generic<Double>();
      }
  }
  class Generic<T> {
  }
  /* Output:
  [Ljava.lang.Object; cannot be cast to [LGeneric;
  Generic[]
  */
  ```

  成功创建泛型类型的数组的唯一方法是创建一个已擦除类型的新数组，并将其强制转换。

  ```java
  public class GenericArray<T> {
      private T[] array;
      @SuppressWarnings("unchecked")
      public GenericArray(int sz) {
          array = (T[]) new Object[sz];
      }
      public void put(int index, T item) {
          array[index] = item;
      }
      public T get(int index) {
          return array[index];
      }
      // Method that exposes the underlying representation:
      public T[] rep() {
          return array;
      }
      public static void main(String[] args) {
          GenericArray<Integer> gai = new GenericArray<>(10);
          try {
              Integer[] ia = gai.rep();
          } catch (ClassCastException e) {
              System.out.println(e.getMessage());
          }
          // This is OK:
          Object[] oa = gai.rep();
      }
  }
  /* Output:
  [Ljava.lang.Object; cannot be cast to
  [Ljava.lang.Integer;
  */
  ```

  和以前一样，我们不能说 `T[] array = new T[sz]` ，所以我们创建了一个 **Object** 数组并将其强制转换。

  `rep()` 方法返回一个 `T[]` ，在主方法中它应该是 `gai` 的 `Integer[]`，但是如果调用它并尝试将结果转换为 `Integer[]` 引用，则会得到 **ClassCastException** ，这再次是因为实际的运行时类型为 `Object[]` 。***由于擦除，数组的运行时类型只能是*** `Object[]`。

  ```java
  public class GenericArray2<T> {
      private Object[] array;
      public GenericArray2(int size) {
          array = new Object[size];
      }
      public void put(int index, T item) {
          array[index] = item;
      }
      @SuppressWarnings("unchecked")
      public T get(int index) {
          return (T) array[index];// this is safe
      }
      @SuppressWarnings("unchecked")
      public T[] rep() {
          return (T[]) array; // Unchecked cast
      }
      public static void main(String[] args) {
          GenericArray2<Integer> gai = new GenericArray2<>(10);
          for (int i = 0; i < 10; i++)
              gai.put(i, i);
          for (int i = 0; i < 10; i++)
              System.out.print(gai.get(i) + " ");
          System.out.println();
          try {
              Integer[] ia = gai.rep();
          } catch (Exception e) {
              System.out.println(e);
          }
      }
  }
  ```

  无法破坏基础数组的类型，该基础数组只能是 `Object[]` 。在内部将数组视为 `Object[]` 而不是 `T[]` 的优点是，我们不太可能会忘记数组的运行时类型并意外地引入了bug，尽管大多数（也许是全部）此类错误会在运行时被迅速检测到。对于新代码：

  ```java
  public class GenericArrayWithTypeToken<T> {
      private T[] array;
      @SuppressWarnings("unchecked")
      public GenericArrayWithTypeToken(Class<T> type,int size){
          array = (T[]) Array.newInstance(type,size);
      }
      public void put(int index, T item) {
          array[index] = item;
      }
      public T get(int index) { return array[index]; }
      // Expose the underlying representation:
      public T[] rep() { return array; }
  
      public static void main(String[] args) {
          GenericArrayWithTypeToken<Integer> gai =
                  new GenericArrayWithTypeToken<>(Integer.class, 10);
          // This now works:
          Integer[] ia = gai.rep();
          System.out.println(ia);
      }
  }
  ```

## 边界

- 边界允许我们对泛型使用的参数类型施加约束，可以在绑定的类型中调用方法。`extends`定义了上边界，`super`定义了下边界。

  基础用法：

  ```java
  public class BasicBounds {
      public static void main(String[] args) {
          Solid<Bounded> solid = new Solid<>(new Bounded());
          solid.color();
          solid.getY();
          solid.getItem();
      }
  }
  
  interface HasColor {
      Color getColor();
  }
  
  class WithColor<T extends HasColor> {
      T item;
      public WithColor(T item) {
          this.item = item;
      }
      T getItem(){
          return item;
      }
      Color color(){
          return item.getColor();
      }
  }
  class Coord{
      public int x,y,z;
  }
  //This fails,Class must be first,then interface
  //class WithColorCoord<T extends HasColor & Coord> {}
  class  WithColorCoord<T extends Coord & HasColor> {
      T item;
      WithColorCoord(T item){
          this.item = item;
      }
      T getItem(){
          return item;
      }
      Color color(){
          return item.getColor();
      }
      int getX() { return item.x; }
      int getY() { return item.y; }
      int getZ() { return item.z; }
  }
  interface Weight{
      int weight();
  }
  //you can have only one
  // concrete class but multiple interfaces:
  class Solid<T extends Coord & HasColor & Weight>{
      T item;
      Solid(T item) { this.item = item; }
      T getItem() { return item; }
      java.awt.Color color() { return item.getColor(); }
      int getX() { return item.x; }
      int getY() { return item.y; }
      int getZ() { return item.z; }
      int weight() { return item.weight(); }
  }
  class Bounded extends Coord implements HasColor,Weight{
      @Override
      public Color getColor() {
          return null;
      }
      @Override
      public int weight() {
          return 0;
      }
  }
  ```

## 通配符

- 通配符：泛型表达式中的问号。

  先来看使用数组的一些约束

  ```java
  public class CovariantArrays {
      public static void main(String[] args) {
          Fruit[] fruit = new Apple[10];
          fruit[0] = new Apple();
          fruit[1] = new Jonathan();
          // Runtime type is Apple[], not Fruit[] or Orange[]:
          try {
              fruit[0] = new Fruit();
          } catch (Exception e) {
              System.out.println(e);
          }
          try {
              // Compiler allows you to add Oranges:
              fruit[0] = new Orange(); // ArrayStoreException
          } catch (Exception e) {
              System.out.println(e);
          }
      }
  }
  
  class Fruit {
  }
  class Apple extends Fruit {
  }
  class Jonathan extends Apple {
  }
  class Orange extends Fruit {
  }
  
  ```

  改用集合代替数组

  ```java
  public class NonCovariantGenerics {
      // // Compile Error: incompatible types:
      ArrayList<Fruit> flist = new ArrayList<Apple>();
  }
  ```

  这里不通过编译是因为，虽然`Apple`是`Fruite`的子类型，但是`ArrayList<Apple>`并不是`ArrayList<Fruite>`的子类型。

  但是，有时你想在两个类型间建立某种向上转型关系。通配符可以产生这种关系。

  ```java
  public class NonCovariantGenerics {
      public static void main(String[] args) {
          List<? extends Fruit> fruits = new ArrayList<>();
          // Compile Error: can't add any type of object:
  //         fruits.add(new Apple());
          // fruits.add(new Fruit());
          // fruits.add(new Object());
          fruits.add(null); // Legal but uninteresting
          fruits.indexOf(new Apple());
          Fruit f = fruits.get(0);
      }
  }
  ```

  `List<? extends Fruit> fruits`可以读做：一个继承自`Fruit`类型的列表。但并不是指这个列表可以持有任何类型的`Fruit`。**为什么上例中调`add()`方法会添加失败呢？**。查看`ArrayList`文档可知，`add`方法接收类型为`E`在这里也就是`? extends Fruit`，由于编译器无法得知这里需要 **Fruit** 的哪个具体子类型，因此拒绝接收任何类型的`Fruit`。而`indexof`方法接收的是`Object`类型，故编译通过。这意味着将由泛型类的设计者来决定哪些调用是“安全的”，并使用 **Object** 类作为它们的参数类型。

  ```java
  public class Holder<T> {
      private T value;
      public Holder(){}
      public Holder(T val){
          value = val;
      }
      public T get() {
          return value;
      }
      public void set(T value) {
          this.value = value;
      }
      @Override
      public boolean equals(Object o) {
          return o instanceof Holder && Objects.equals(value, ((Holder) o).value);
      }
      @Override
      public int hashCode() {
          return Objects.hashCode(value);
      }
      public static void main(String[] args) {
          Holder<Apple> appleHolder = new Holder<>(new Apple());
          Apple apple = appleHolder.get();
          appleHolder.set(apple);
          //Holder<Fruit> fruitHolder = appleHolder;// Cannot upcast
          Holder<? extends Fruit> fruitHolder = appleHolder;// ok
          Fruit fruit = fruitHolder.get();
          apple = (Apple)fruitHolder.get();
          try{
              Orange c = (Orange) fruitHolder.get();// no warning
          }catch (Exception e){
              System.out.println(e);
          }
  //        fruit.set(new Apple()); // Cannot call set()
  //        fruit.set(new Fruit()); // Cannot call set()
          System.out.println(fruitHolder.equals(apple)); // OK
      }
  }
  ```

- 超类型通配符

  `<? super MyClass>`:由某个特定类的任何基类来界定

  ```java
  public class SuperTypeWildcards {
      static void writeTo(List<? super Apple> apples) {
          apples.add(new Apple());
          apples.add(new Jonathan());
          // apples.add(new Fruit()); // Error
      }
  }
  ```

  参数 **apples** 是 **Apple** 的某种基类型的 **List**，这样你就知道向其中添加 **Apple** 或 **Apple** 的子类型是安全的。因为 **Apple** 是下界，所以你知道向这样的 **List** 中添加 **Fruit** 是不安全的，因为这将使这个 **List** 敞开口子，从而可以向其中添加非 **Apple** 类型的对象，而这是违反静态类型安全的。

  ```java
  public class GenericReading {
      static List<Apple> apples = Arrays.asList(new Apple());
      static List<Fruit> fruit = Arrays.asList(new Fruit());
      static <T> T readExact(List<T> list){
          return list.get(0);
      }
      static void f1(){
          Apple apple = readExact(apples);
          Fruit fruit = readExact(GenericReading.fruit);
          fruit = readExact(apples);
      }
  
      static class Reader<T>{
          T readExact(List<T> list){
              return list.get(0);
          }
      }
      static void f2(){
          Reader<Fruit> fruitReader = new Reader<>();
          Fruit f = fruitReader.readExact(fruit);
          // error: incompatible types: List<Apple> cannot be converted to List<Fruit>
          // fruitReader.readExact(apples);
      }
      static class CovariantReader<T>{
          T readCovariant(List<? extends T> list){
              return list.get(0);
          }
      }
      static void f3(){
          CovariantReader<Fruit> covariantReader = new CovariantReader<>();
          Fruit fruit = covariantReader.readCovariant(GenericReading.fruit);
          Fruit a = covariantReader.readCovariant(apples);
  
      }
      public static void main(String[] args) {
          f1();
          f2();
          f3();
      }
  }
  
  ```

  对于泛型类来说，当你创建这个类的实例时，就要为这个类确定参数。就像在 `f2()` 中看到的，`fruitReader` 实例可以从 `List` 中读取一个 `Fruit` ，因为这就是它的确切类型。但此时它却不能接受`apples`。 为了修正这个问题，`CovariantReader.readCovariant()` 方法将接受 `List<?extends T>` 。

- `<? extends T> `跟`<? super T>`差异总结

  ```java
  private void clientMethod(){
          List<Fruit> fruits = new ArrayList<>();
          extendsTest(fruits);
          List<Apple> apples = new ArrayList<>();
          extendsTest(apples);
          List<Orange> oranges = new ArrayList<>();
          extendsTest(oranges);
          List<Object> objects = new ArrayList<>();
          extendsTest(objects); // error:can not applied
  
          superTest(fruits);
          superTest(apples); // error
          superTest(oranges); // error
          superTest(objects);
      }
  	// 定义了下界，赋值时可以赋值子类型，而不能添加任何类型。因为不确定会有哪个子类型赋值，
  	//为保证安全不允许添加
      private void extendsTest(List<? extends Fruit> fruits){
          fruits.add(new Apple()); //error: can not applied
          fruits.add(new Fruit()); // error
          fruits.add(new Orange());// error
          fruits.add(new Object());// error
          fruits.add(null);
      }
  	// super 定义了下界，只能向其中添加子类型。赋值时，只能赋值自身跟父类型
      private void superTest(List<? super Fruit> fruits){
          fruits.add(new Apple()); 
          fruits.add(new Fruit());
          fruits.add(new Orange());
          fruits.add(new Object()); // error
          fruits.add(null);
      }
  }
  ```

- 无界通配符

  无界通配符`<?>`跟原生类型并不一样：

  ```java
  public class UnboundedWildcards1 {
      static List list1;
      static List<?> list2;
      static List<? extends Object> list3;
  
      static void assign1(List list){
          list1 = list;
          list2 = list;
          // warning: [unchecked] unchecked conversion
          list3 = list;
      }
      static void assign2(List<?> list){
          list1 = list;
          list2 = list;
          list3 = list;
      }
      static void assign3(List<? extends Object> list){
          list1 =list;
          list2 =list;
          list3 =list;
      }
  
      public static void main(String[] args) {
          assign1(new ArrayList());
          assign2(new ArrayList());
          assign3(new ArrayList());// warning:uncheck assign
          assign1(new ArrayList<>());
          assign2(new ArrayList<>());
          assign3(new ArrayList<>());
          List<?> wildList = new ArrayList();
          wildList = new ArrayList<>();
          assign1(wildList);
          assign2(wildList);
          assign3(wildList);
      }
  }
  ```

  `<?>`在这里的意思是：“我是想用 Java 的泛型来编写这段代码，我在这里并不是要用原生类型，但是在当前这种情况下，泛型参数可以持有任何类型。”看第二个实示例：

## 泛型异常

- 由于擦除的原因，**catch** 语句不能捕获泛型类型的异常。泛型类也不能直接或间接继承自 **Throwable**（这将进一步阻止你去定义不能捕获的泛型异常）。 但是，类型参数可能会在一个方法的 **throws** 子句中用到。这使得你可以编写随检查型异常类型变化的泛型代码：

  ```java
  public class ThrowGenericException {
      public static void main(String[] args) {
          ProcessRunner<String, Failure1> runner = new ProcessRunner<>();
          for (int i = 0; i < 3; i++) {
              runner.add(new Processor1());
          }
          try {
              System.out.println(runner.processAll());
          } catch (Failure1 failure1) {
              System.out.println(failure1);
          }
          ProcessRunner<Integer, Failure2> runner2 =
                  new ProcessRunner<>();
          for(int i = 0; i < 3; i++)
              runner2.add(new Processor2());
          try {
              System.out.println(runner2.processAll());
          } catch(Failure2 e) {
              System.out.println(e);
          }
      }
  }
  
  interface Processor<T,E extends Exception>{
      void process(List<T> resultCollector) throws E;
  }
  class ProcessRunner<T,E extends Exception> extends
          ArrayList<Processor<T,E>>{
      List<T> processAll() throws E{
          List<T> resultCollector = new ArrayList<>();
          for (Processor<T, E> processor : this) {
              processor.process(resultCollector);
          }
          return resultCollector;
      }
  }
  class Failure1 extends Exception{}
  
  class Processor1 implements Processor<String,Failure1>{
      static int count =3;
      @Override
      public void process(List<String> resultCollector) throws Failure1 {
          if(count-- > 1)
              resultCollector.add("Hep!");
          else
              resultCollector.add("Ho!");
          if(count < 0)
              throw new Failure1();
      }
  }
  class Failure2 extends Exception {}
  class Processor2 implements Processor<Integer,Failure2>{
      static int count = 2;
      @Override
      public void process(List<Integer> resultCollector) throws Failure2 {
          if(count-- == 0)
              resultCollector.add(47);
          else {
              resultCollector.add(11);
          }
          if(count < 0)
              throw new Failure2();
      }
  }
  ```

## 混型

- 概念：混合多个类的能力，以产生一个可以表示混型中所有类型的类。

  先看与接口混合的例子

  ```java
  public class Mixins {
      public static void main(String[] args) {
          Mixin mixin1 = new Mixin();
          Mixin mixin2 = new Mixin();
          mixin1.set("test string 1");
          mixin2.set("test string 2");
          System.out.println(mixin1.get() + " " +
                  mixin1.getStamp() +  " " + mixin1.getSerialNumber());
          System.out.println(mixin2.get() + " " +
                  mixin2.getStamp() +  " " + mixin2.getSerialNumber());
      }
  }
  
  interface TimeStamped {
      long getStamp();
  }
  class TimeStampedImp implements TimeStamped {
      private final long timeStamp;
      TimeStampedImp() {
          timeStamp = new Date().getTime();
      }
      @Override
      public long getStamp() {
          return timeStamp;
      }
  }
  interface SerialNumbered {
      long getSerialNumber();
  }
  class SerialNumberedImp implements SerialNumbered {
      private static long counter = 1;
      private final long serialNumber = counter++;
      @Override
      public long getSerialNumber() {
          return serialNumber;
      }
  }
  interface Basic {
      void set(String val);
      String get();
  }
  class BasicImp implements Basic {
      private String value;
      @Override
      public void set(String val) { value = val; }
      @Override
      public String get() { return value; }
  }
  class Mixin extends BasicImp implements TimeStamped,SerialNumbered{
      private TimeStamped timeStamp = new TimeStampedImp();
      private SerialNumbered serialNumber =
              new SerialNumberedImp();
      @Override
      public long getStamp() {
          return timeStamp.getStamp();
      }
      @Override
      public long getSerialNumber() {
          return serialNumber.getSerialNumber();
      }
  }
  ```

  可以看出，`Mixin`类使用的是委托。因此每个混入类型都要求在 **Mixin** 中有一个相应的域，而你必须在 **Mixin** 中编写所有必需的方法，将方法调用转发给恰当的对象。这个示例使用了非常简单的类，但是当使用更复杂的混型时，代码数量会急速增加。

- **装饰器**是通过使用组合和形式化结构（可装饰物/装饰器层次结构）来实现的，而混型是基于继承的。因此可以将基于参数化类型的混型当作是一种泛型装饰器机制，这种机制不需要装饰器设计模式的继承结构。 前面的示例可以被改写为使用装饰器

  ```java
  public class Decoration {
      public static void main(String[] args) {
          TimeStamped t = new TimeStamped(new Basic());
          TimeStamped t2 = new TimeStamped(new SerialNumbered(new Basic()));
          //- t2.getSerialNumber(); // Not available
          SerialNumbered s = new SerialNumbered(new Basic());
          SerialNumbered s2 = new SerialNumbered(
                  new TimeStamped(new Basic()));
          //- s2.getStamp(); // Not available
      }
  }
  class Basic{
      private String value;
      public void set(String val){
          this.value = val;
      }
      public String get() { return value; }
  }
  class Decorator extends Basic{
      protected Basic basic;
      public Decorator(Basic basic) {
          this.basic = basic;
      }
      @Override
      public void set(String val) {
          basic.set(val);
      }
      @Override
      public String get() {
          return basic.get();
      }
  }
  class TimeStamped extends Decorator{
      private final long timeStamp;
      public TimeStamped(Basic basic) {
          super(basic);
          timeStamp = new Date().getTime();
      }
      public long getStamp() { return timeStamp; }
  }
  class SerialNumbered extends Decorator{
      private static long counter = 1;
      private final long serialNumber = counter++;
      public SerialNumbered(Basic basic) {
          super(basic);
      }
      public long getSerialNumber() { return serialNumber; }
  }
  ```

  尽管可以添加多个层，但是最后一层才是实际的类型，因此只有最后一层的方法是可视的，而混型的类型是所有被混合到一起的类型。因此对于装饰器来说，其明显的缺陷是它只能有效地工作于装饰中的一层（最后一层），而混型方法显然会更自然一些。

- 与动态代理混合；使用动态代理来创建一种比装饰器更贴近混型模型的机制

  ```java
  public class DynamicProxyMixin {
      public static void main(String[] args) {
          Object mixin = MixinProxy.newInstance(
                  tuple(new BasicImp(), Basic.class),
                  tuple(new TimeStampedImp(), TimeStamped.class),
                  tuple(new SerialNumberedImp(), SerialNumbered.class));
          Basic b = (Basic)mixin;
          TimeStamped t = (TimeStamped)mixin;
          SerialNumbered s = (SerialNumbered)mixin;
          b.set("Hello");
          System.out.println(b.get());
          System.out.println(t.getStamp());
          System.out.println(s.getSerialNumber());
      }
  }
  class MixinProxy implements InvocationHandler{
      Map<String, Object> delegatesByMethod;
      MixinProxy(Tuple2<Object,Class<?>>... pairs){
          delegatesByMethod = new HashMap<>();
          for (Tuple2<Object, Class<?>> pair : pairs) {
              for (Method method : pair.b.getMethods()) {
                  String methodName = method.getName();
                  if(!delegatesByMethod.containsKey(methodName))
                      delegatesByMethod.put(methodName, pair.a);
              }
          }
      }
      @Override
      public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
          String methodName = method.getName();
          Object delegate = delegatesByMethod.get(methodName);
          return method.invoke(delegate, args);
      }
      public static Object newInstance(Tuple2... pairs){
          Class[] interfaces = new Class[pairs.length];
          for(int i = 0; i < pairs.length; i++) {
              interfaces[i] = (Class)pairs[i].b;
          }
          ClassLoader cl = pairs[0].a.getClass().getClassLoader();
          return Proxy.newProxyInstance(cl, interfaces, new MixinProxy(pairs));
      }
  
  }
  /* Output:
  Hello
  1494331653339
  1
  */
  ```

## 潜在类型机制

- 潜在类型机制是一种代码组织和复用机制。有了它，编写出的代码相对于没有它编写出的代码，能够更容易地复用。代码组织和复用是所有计算机编程的基本手段

  ```java
  public interface Performs {
      void speak();
      void sit();
  }
  class PerformingDog extends Dog implements Performs {
      @Override
      public void speak() { System.out.println("Woof!"); }
      @Override
      public void sit() { System.out.println("Sitting"); }
      public void reproduce() {}
  }
  class Robot implements Performs {
      public void speak() { System.out.println("Click!"); }
      public void sit() { System.out.println("Clank!"); }
      public void oilChange() {}
  }
  class Communicate {
      public static <T extends Performs> void perform(T performer){
          performer.speak();
          performer.sit();
      }
  }
  public class DogsAndRobots {
      public static void main(String[] args) {
          Communicate.perform(new PerformingDog());
          Communicate.perform(new Robot());
      }
  }
  /* Output:
  Woof!
  Sitting
  Click!
  Clank!
  */
  ```

  很明显，这个例子中方法`perform`不需要使用泛型了工作，它的参数可以直接指定`Performer`类型。因为是使用该方法的那些类已经强制实现了`Performer`接口。这就是**Java**直接支持潜在类型机制。但提供了补偿机制。

  反射：

  ```java
  public class LatentReflection {
      public static void main(String[] args) {
          CommunicateReflectively.perform(new SmartDog());
          CommunicateReflectively.perform(new Robot());
          CommunicateReflectively.perform(new Mime());
      }
  }
  // Does not implement Performs:
  class Mime{
      public void walkAgainstTheWind(){}
      public void sit() {
          System.out.println("Pretending to sit");
      }
      public void pushInvisibleWalls() {}
      @Override
      public String toString() { return "Mime"; }
  }
  class SmartDog{
      public void speak() { System.out.println("Woof!"); }
      public void sit() { System.out.println("Sitting"); }
      public void reproduce() {}
  }
  class CommunicateReflectively{
      public static void perform(Object speaker){
          Class<?> spkr = speaker.getClass();
          try {
              try {
                  Method speak = spkr.getMethod("speak");
                  speak.invoke(speaker);
              } catch(NoSuchMethodException e) {
                  System.out.println(speaker + " cannot speak");
              }
              try {
                  Method sit = spkr.getMethod("sit");
                  sit.invoke(speaker);
              } catch(NoSuchMethodException e) {
                  System.out.println(speaker + " cannot sit");
              }
          } catch(SecurityException |
                  IllegalAccessException |
                  IllegalArgumentException |
                  InvocationTargetException e) {
              throw new RuntimeException(speaker.toString(), e);
          }
  
      }
  }
  /* Output:
  Woof!
  Sitting
  Click!
  Clank!
  Mime cannot speak
  Pretending to sit
  */
  ```

  上例中，这些类完全是彼此分离的，没有任何公共基类（除了 **Object** ）或接口。通过反射, `CommunicateReflectively.perform()` 能够动态地确定所需要的方法是否可用并调用它们。

  但是反射存在缺陷它将所有的类型检查都转移到了运行时，因此在许多情况下并不是我们所希望的。如果能够实现编译期类型检查，这通常会更符合要求。

  假设有一个这样的场景：想要创建一个 `apply()` 方法，它能够将任何方法应用于某个序列中的所有对象。这种情况下使用接口不适合，因为你想要将任何方法应用于一个对象集合，而接口不可能描述任何方法。看使用反射来实现：

  ```java
  public class Apply {
      public static <T, S extends Iterable<T>> void apply(S seq, Method f,Object...  args){
          try {
              for(T t: seq)
                  f.invoke(t, args);
          } catch(IllegalAccessException |
                  IllegalArgumentException |
                  InvocationTargetException e) {
              // Failures are programmer errors
              throw new RuntimeException(e);
          }
      }
  }
  public class Shape {
      private static long counter = 0;
      private final  long id = counter++;
      @Override
      public String toString() {
          return getClass().getSimpleName()+ " " + id;
      }
      public void rotate(){
          System.out.println(this + " rotate");
      }
      public void resize(int newSize){
          System.out.println(this + " resize" + newSize);
      }
  }
  public class Square extends Shape {
  }
  public class FilledList<T> extends ArrayList<T> {
      public FilledList(Supplier<T> gen,int size){
          Suppliers.fill(this,gen,size);
      }
      public FilledList(T t,int size){
          for (int i = 0; i < size; i++) {
              this.add(t);
          }
      }
  }
  public class ApplyTest {
      public static void main(String[] args) throws Exception {
          List<Shape> shapes = Suppliers.
                  create(ArrayList::new, Shape::new, 3);
          Apply.apply(shapes,Shape.class.getMethod("rotate"));
          Apply.apply(shapes,Shape.class.getMethod("resize", int.class),7);
          List<Square> squares =
                  Suppliers.create(ArrayList::new, Square::new, 3);
          Apply.apply(squares, Shape.class.getMethod("rotate"));
          Apply.apply(squares, Shape.class.getMethod("resize", int.class), 7);
  
          Apply.apply(new FilledList<>(Shape::new, 3),
                  Shape.class.getMethod("rotate"));
          Apply.apply(new FilledList<>(Square::new, 3),
                  Shape.class.getMethod("rotate"));
      }
  }
  ```

  如上可以看到，`ApplyTest`中的`apply`方法可以接受任何实现了`Iterable`接口的类。不过反射的实现速度比较慢。下面展示使用Java 8 的函数式方法改进：

  ```java
  public class ApplyFunctional {
      public static void main(String[] args) {
          Stream.of(Stream.generate(Shape::new).limit(2),
                  Stream.generate(Square::new).limit(2))
                  .flatMap(c -> c)// flatten into on stream
                  .peek(Shape::rotate) //  `peek()` 执行一个操作（此处是出于副作用），并在未更改																		的情况下传递对象
                  .forEach(s -> ((Shape) s).resize(7));
          new FilledList<>(Shape::new, 2)
                  .forEach(Shape::rotate);
          new FilledList<>(Square::new, 2)
                  .forEach(Shape::rotate);
      }
  }
  ```

- **Java 8**的辅助潜在类型

  重写`DogsAndRobots`:

  ```java
  public class DogsAndRobotMethodReferences {
      public static void main(String[] args) {
          CommunicateNew.perform(new PerformingDogNew(), PerformingDogNew::speak,
                  PerformingDogNew::sit);
          CommunicateNew.perform(new Mime(), Mime::walkAgainstTheWind,
                  Mime::pushInvisibleWalls);
      }
  }
  
  class PerformingDogNew extends Dog {
      public void speak() {
          System.out.println("Woof!");
      }
      public void sit() {
          System.out.println("Sitting");
      }
      public void reproduce() {
      }
  }
  
  class RobotNew {
      public void speak() {
          System.out.println("Click!");
      }
      public void sit() {
          System.out.println("Clank!");
      }
      public void oilChange() {
      }
  }
  class CommunicateNew {
      public static <P> void perform(P performer,
                                     Consumer<P> actionOne,
                                     Consumer<P> actionTwo) {
          actionOne.accept(performer);
          actionTwo.accept(performer);
      }
  }
  
  ```

- 使用**Suppliers**类的通用方法

  ```java
  public class Suppliers {
      // Create a collection and fill it:
      public static <T, C extends Collection<T>> C
      create(Supplier<C> factory, Supplier<T> gen, int n) {
          return Stream.generate(gen)
                  .limit(n)
                  .collect(factory, C::add, C::addAll);
      }
  
      // Fill an existing collection:
      public static <T, C extends Collection<T>>
      C fill(C coll, Supplier<T> gen, int n) {
          Stream.generate(gen)
                  .limit(n)
                  .forEach(coll::add);
          return coll;
      }
      // Use an unbound method reference to
      // produce a more general method:
      public static <H, A> H fill(H holder,
                                  BiConsumer<H, A> adder, Supplier<A> gen, int n) {
          Stream.generate(gen)
                  .limit(n)
                  .forEach(a -> adder.accept(holder, a));
          return holder;
      }
  
  }
  ```

  测试

  ```java
  public class BankTeller {
      public static void serve(Teller t, Customer c) {
          System.out.println(t + " serves " + c);
      }
  
      public static void main(String[] args) {
          // Demonstrate create():
          RandomList<Teller> tellers =
                  Suppliers.create(
                          RandomList::new, Teller::new, 4);
          // Demonstrate fill():
          List<Customer> customers = Suppliers.fill(
                  new ArrayList<>(), Customer::new, 12);
          customers.forEach(c ->
                  serve(tellers.select(), c));
          // Demonstrate assisted latent typing:
          Bank bank = Suppliers.fill(
                  new Bank(), Bank::put, BankTeller::new, 3);
          // Can also use second version of fill():
          List<Customer> customers2 = Suppliers.fill(
                  new ArrayList<>(),
                  List::add, Customer::new, 12);
      }
  }
  class Customer {
      private static long counter = 1;
      private final long id = counter++;
      @Override
      public String toString() {
          return "Customer" + id;
      }
  }
  class Teller {
      private static long counter = 1;
      private final long id = counter++;
      @Override
      public String toString() {
          return "Teller " + id;
      }
  }
  class Bank {
      private List<BankTeller> tellers =
              new ArrayList<>();
      public void put(BankTeller bt) {
          tellers.add(bt);
      }
  }
  ```

## 总结

- 即便“狗在猫列表中”这个论据经常被用来证明泛型是必要的，但是它仍旧是有问题的。就像我在本章开头声称的，我不相信这就是泛型这个概念真正的含义。相反，泛型正如其名称所暗示的：它是一种方法，通过它可以编写出更“泛化”的代码，这些代码对于它们能够作用的类型具有更少的限制，因此单个的代码段可以应用到更多的类型上