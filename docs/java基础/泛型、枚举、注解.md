# 泛型

## 泛型的定义跟作用

- 一般来说，一个类或者方法只能适用于特定的类或者基本数据类型，有局限性。

- 多态可以弥补这种局限。但依然有不足，比如方法参数指定了接口，新创建的类要想适用这个方法，必须要实现这个接口(有时候要实现接口的方法)。

- 泛型(*generic*)：适用于很多类型。通过解耦类或方法与所使用的类型之间的约束，使得类或方法具备最宽泛的表达力。

- 促成泛型出现的最主要的动机之一是为了创建**集合类**。几乎所有程序在运行过程中都会涉及到一组对象，集合成了复用率较高的类库之一

  泛型出现演进：

  ```java
  public class Holder {
      private Automobile a;
      public Holder(Automobile a) {
          this.a = a;
      }
      public Automobile getA() {
          return a;
      }
  }
  class Automobile{}
  ```

  很明显`Holder`的复用性不高。无法持有其他非`Automobile`对象。*java 5*之前:

  ```java
  public class ObjectHolder {
      private Object a;
      public ObjectHolder(Object a) {
          this.a = a;
      }
      public Object get() {
          return a;
      }
      public void set(Object a) {
          this.a = a;
      }
      public static void main(String[] args) {
          ObjectHolder objectHolder = new ObjectHolder(new Automobile());
          Automobile au = (Automobile)objectHolder.get();
          objectHolder.set("Not an Automobile");
          String str = (String)objectHolder.get();
          objectHolder.set(1);
          Integer x  = (Integer)objectHolder.get();
      }
  }
  ```

  这个还是存在问题。取出元素时有可能出现类型转换异常。如果用的是`Object[]`，那么这个`Holder`就可以存储多种类型的数据，添加元素跟取出元素，都不能在编译阶段就发现问题。泛型可以做到。

  ```java
  public class GenericHolder<T> {
      private T a;
      public GenericHolder() {}
      public T get() {return a;}
      public void set(T a) {this.a = a;}
      
      public static void main(String[] args) {
          GenericHolder<Automobile> genericHolder = new GenericHolder<>();
          genericHolder.set(new Automobile());
          Automobile automobile = genericHolder.get();// No cast needed
          // genericHolder.set("Not an Automobile");// Type checked error
      }
  }
  ```

## A Tuple Library  

- 元组(*Tuple*):它是将一组对象直接打包存储于单一对象中。可以从该对象读取其中的元素，但不允许向其中存储新对象(这个概念也称为 *数据传输对象* 或 *信使* )。(可以解决`return` 语句只能返回单个对象，而实际想返回多个对象问题)。

  ```java
  public class Tuple2<A,B> {
      public final A a;
      public final B b;
      public Tuple2(A a1, B b1) {
          this.a = a1;
          this.b = b1;
      }
      public String rep(){return a +","+ b;}
      @Override
      public String toString() {
          return "(" +rep() + ")";
      }
  }
  ```

  上例中，元组的使用程序可以读取 `a` 和 `b` 然后对它们执行任何操作，但无法对 `a` 和 `b` 重新赋值。

  ```java
  public class Tuple3<A,B,C> extends Tuple2<A,B>{
      private final C c;
      public Tuple3(A a, B b, C c) {
          super(a, b);
          this.c = c;
      }
      @Override
      public String rep() {
          return super.rep() + ", " + c;
      }
  }
  public class TupleTest {
      private static Tuple2<String,Integer> getTuple2(){
          return new Tuple2<>("h1",47);
      }
      private static Tuple3<Amphibian,String,Integer> getTuple3(){
          return new Tuple3<>(new Amphibian(),"hi",47);
      }
      public static void main(String[] args) {
          Tuple2<String, Integer> tuple2 = getTuple2();
          // tuple2.a ="there";// Compile error:final
      }
  }
  ```

  有了泛型，你可以很容易地创建元组，令其返回一组任意类型的对象。

## A Stack Class

- 泛型实现内部链式存储机制示例

  ```java
  public class LinkedStack<T> {
      private static class Node<U> {
        U item;
          Node<U> next;
          Node() {
              item = null;
              next = null;
          }
          public Node(U item, Node<U> next) {
              this.item = item;
              this.next = next;
          }
          boolean end(){
              return item == null && next == null;
          }
      }
      private Node<T> top = new Node<>();
      public void push(T item){
          top = new Node<>(item,top);
      }
      public T top(){
          T result = top.item;
          if (!top.end()) {
              top = top.next;
          }
          return result;
      }
       public static void main(String[] args) {
          LinkedStack<String> list = new LinkedStack<>();
          for (String s : "Phasers on stun!".split(" ")) {
              list.push(s);
          }
          String s;
          while ((s=list.pop())!= null) {
              System.out.println(s);
          }
      }
  }
  ```
  

## RandomList  

- 加入需要一个持有特定类型对象的列表。每次调用它的 `select()` 方法时都随机返回一个元素。如果希望这种列表可以适用于各种类型，就需要使用泛型

  ```java
  public class RandomList<T> extends ArrayList<T> {
      private Random random = new Random(47);
  
      public T select() {
          return get(random.nextInt(size()));
      }
      public static void main(String[] args) {
          RandomList<String> rs = new RandomList<>();
          Arrays.stream("The quick brown fox jumped over the lazy brown dog".split(" "))
                  .forEach(rs::add);
          IntStream.range(0, 11).forEach(i -> System.out.println(rs.select() + ""));
      }
  }
  ```

## Generic Interfaces  

- **生成器**(*generator*)，一种专门负责创建对象的类。是 **工厂方法** 设计模式的一种应用。例如 `java.util.function` 类库中的 `Supplier` 就是一个生成器，调用其 `get()` 获取对象。`get()` 是泛型方法，返回值为类型参数 `T`。

  ```java
  public class Coffee {
      private static long counter = 0;
      private final long id = counter++;
      @Override
      public String toString() {
          return getClass().getSimpleName() + " " + id;
      }
  }
  public class Americano extends Coffee {}
  public class Breve extends Coffee {}
  public class Cappuccino extends Coffee {}
  public class Latte extends Coffee {}
  public class Mocha extends Coffee {}
  ```

  编写一个类，实现 `Supplier` 接口，它能够随机生成不同类型的 `Coffee` 对象：

  ```java
  public class CoffeeSupplier implements Supplier<Coffee>, Iterable<Coffee> {
      private Class<?>[] types = {Latte.class, Mocha.class, Cappuccino.class,
              Americano.class, Breve.class};
      private static Random random = new Random(47);
      public CoffeeSupplier() {
      }
      private int size = 0;
      public CoffeeSupplier(int size) {
          this.size = size;
      }
      @Override
      public Iterator<Coffee> iterator() {
          return new CoffeeIterator();
      }
      @Override
      public Coffee get() {
          try {
              return (Coffee) types[random.nextInt(types.length)].newInstance();
          } catch (InstantiationException | IllegalAccessException e) {
              throw new RuntimeException();
          }
      }
      class CoffeeIterator implements Iterator<Coffee> {
          int count = size;
          @Override
          public boolean hasNext() {
              return count > 0;
          }
          @Override
          public Coffee next() {
              count--;
              return CoffeeSupplier.this.get();
          }
          @Override
          public void remove() {
              throw new UnsupportedOperationException();
          }
      }
      public static void main(String[] args) {
          for(Coffee c : new CoffeeSupplier(5))
              System.out.println(c);
      }
  }
  
  // 输出结果
  Americano 0
  Latte 1
  Americano 2
  Mocha 3
  Mocha 4
  Breve 5
  Americano 6
  Latte 7
  Cappuccino 8
  Cappuccino 9
  ```

- 生成`Fibonacci `数列例子：

  ```java
  public class Fibonacci implements Supplier<Integer> {
      private int count = 0;
      @Override
      public Integer get() {
          return fib(count++);
      }
      private int fib(int n) {
          if ((n < 2)) {
              return 1;
          }
          return fib(n - 2) + fib(n-1);
      }
      public static void main(String[] args) {
          Stream.generate(new Fibonacci())
                  .limit(18).
                  forEach(System.out::println);
      }
  }
  // 输出结果
  1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584
  ```

- 假如我们现在不能修改`Fibonacci`接口(并不是总能拥有源码控制权)，但同时有想`Fibonacci`能够具有迭代功能。这个时候就可以使用**适配器模式**(*Adapter*)。[也就是客户端需要的是接口类型是`Iterable`，但`Fibonacci`不是这接口类型，又想应用到客户端]。下面使用两种方式实现这种模式：委托跟继承。

  ```java
  public class IterableFibonacci implements Iterable<Integer> {
      private int n;
      private Fibonacci fibonacci;
      public IterableFibonacci(int n, Fibonacci fibonacci) {
          this.n = n;
          this.fibonacci = fibonacci;
      }
      @Override
      public Iterator<Integer> iterator() {
          return new Iterator<Integer>() {
              @Override
              public boolean hasNext() {
                  return n > 0;
              }
              @Override
              public Integer next() {
                  n--;
                  return fibonacci.get();
              }
          };
      }
      public static void main(String[] args) {
          Fibonacci fibonacci = new Fibonacci();
          for (Integer i : new IterableFibonacci(18, fibonacci)) {
              System.out.print(i + " ");
          }
      }
  }
  ```

  另一种常见方式为继承：

  ```java
  public class IterableFibonacci extends Fibonacci implements Iterable<Integer> {
      private int n;
      public IterableFibonacci(int count	) { n = count; }
      @Override
      public Iterator<Integer> iterator() {
          return new Iterator<Integer>() {
              @Override
              public boolean hasNext() { return n > 0; }
              @Override
              public Integer next() {
                  n--;
                  return IterableFibonacci.this.get();
              }
              @Override
              public void remove() { // Not implemented
                  throw new UnsupportedOperationException();
              }
          };
      }
      public static void main(String[] args) {
          for(int i : new IterableFibonacci(18))
              System.out.print(i + " ");
      }
  }
  ```


## Generic Methods  

- 类可能是泛型，也可能不是，与他的方法是不是泛型并没有什么关系。

- 泛型方法独立于类。通常来说，“尽可能”使用泛型方法，通常将单个方法泛型化要比将整个类泛型化更清晰易懂。

- 如果方法是`static`的，那么该方法无法使用该类的泛型类参数。如果要使用泛型类型参数，那么该方法不能是`static`

  泛型方法定义示例：

  ```java
  public class GenericMethods {
      public <T> void gMethod(T x){ //将泛型参数列表放置在返回值之前
          System.out.println(x.getClass().getName());
      }
      public static void main(String[] args) {
          GenericMethods gm = new GenericMethods();
          gm.gMethod("");
          gm.gMethod(1);
          gm.gMethod(1.0);
          gm.gMethod(1.0F);
          gm.gMethod('c');
          gm.gMethod(gm);
      }
  }
  ```

- 对于泛型类，在示例化时必须制定泛型参数。而使用泛型方法时通常不需要指定泛型参数，因为编译器会通过**类型推断**找出相应的类型。调用泛型方法看起来跟调用普通方法一样。

- 泛型方法跟可变参数

  ```java
  public class GenericVarargs {
      @SafeVarargs
      public static <T> List<T> makeList(T... args) {
          List<T> result = new ArrayList<>();
          for (T item : args) {
              result.add(item);
          }
          return result;
      }
      public static void main(String[] args) {
          List<String> ls = makeList("A");
          System.out.println(ls);
          ls = makeList("A", "B", "C");
          System.out.println(ls);
          ls = makeList("ABCDEFGHIJK".split(""));
          System.out.println(ls);
      }
  }
  ```

  `@SafeVarargs` 注解保证我们不会对变长参数列表进行任何修改。可以消除编译器的警告。

## 泛型Supplier

- 这是一个可以利用任意类的无参构造方法来实例化该类的 `Supplier` 。为了减少键入，它还包括一个用于生成 `BasicSupplier` 的泛型方法

  ```java
  public class BasicSupplier<T> implements Supplier<T> {
      private Class<T> type;
      private BasicSupplier(Class<T> type) {
          this.type = type;
      }
      @Override
      public T get() {
          // Assumes type is a public class:
          try {
              return type.newInstance();
          } catch (InstantiationException | IllegalAccessException e) {
             throw new RuntimeException();
          }
      }
      // Produce a default Supplier from a type token:
       static <U> Supplier<U> create(Class<U> type){
          return new BasicSupplier<>(type);
      }
  }
  ```

  `create()` 方法提供了 `BasicSupplier.create(MyType.class)`这种较简洁的语法来代替较笨拙的 `new BasicSupplier (MyType.class)`

  ```java
  public class CountedObject {
      private static long counter = 0;
      private final long id = counter++;
      public long id(){
          return id;
      }
      @Override
      public String toString() {
          return "CountedObject " + id;
      }
  }
  public class BasicSupplierDemo {
      public static void main(String[] args) {
          Stream.generate(BasicSupplier.create(CountedObject.class))
                  .limit(5).forEach(System.out::println);
      }
  }
  ```

  泛型方法减少了产生 **Supplier** 对象所需的代码量。 Java 泛型强制传递 **Class** 对象，以便在 `create()` 方法中将其用于类型推断。

## 简化 Tuple 的使用

- 使用类型参数推断和静态导入，我们将把早期的元组重写为更通用的库

  ```java
  public class Tuple {
      public static <A, B> Tuple2<A, B> tuple(A a, B b) {
          return new Tuple2<>(a, b);
      }
      public static <A, B, C> Tuple3<A, B, C> tuple(A a, B b, C c) {
          return new Tuple3<>(a, b, c);
      }
      public static <A, B, C, D> Tuple4<A, B, C, D> tuple(A a, B b, C c, D d) {
          return new Tuple4<>(a, b, c, d);
      }
  }
  public class TupleTest2 {
      static Tuple2<String,Integer> f(){
          return tuple("hi",47);
      }
      static Tuple2 f2() { return tuple("hi", 47); }
      static Tuple3<Amphibian, String, Integer> g() {
          return tuple(new Amphibian(), "hi", 47);
      }
      static Tuple4<Vehicle , Amphibian, String, Integer> h() {
          return tuple(new Vehicle(), new Amphibian(), "hi", 47);
      }
  
      public static void main(String[] args) {
          Tuple2<String, Integer> ttsi = f();
          System.out.println(ttsi);
          System.out.println(f2());
          System.out.println(g());
          System.out.println(h());
      }
  }
  ```

  `f()` 返回一个参数化的 `Tuple 2` 对象，而 `f2()` 返回一个未参数化的 `Tuple2`对象。编译器不会在这里警告 `f2()` ，因为返回值未以参数化方式使用。从某种意义上说，它被“向上转型”为一个未参数化的 `Tuple2` 。 但是，如果尝试将 `f2()` 的结果放入到参数化的 `Tuple2` 中，则编译器将发出警告。

## Set 工具

- 由`Set`表示的数学关系

  ```java
  public class Sets {
      // 并集
      public static <T> Set<T> union(Set<T> a, Set<T> b) {
          // copy its reference into a new HashSet,
          // so the argument Sets are not directory modified
          Set<T> result = new HashSet<>(a);
          result.addAll(b);
          return result;
      }
      // 交集
      public static <T> Set<T> intersection(Set<T> a, Set<T> b) {
          HashSet<T> result = new HashSet<>(a);
          result.retainAll(b);
          return result;
      }
      // 从superset中移除跟subset中相同的元素
      public static <T> Set<T> difference(Set<T> superset, Set<T> subset) {
          HashSet<T> result = new HashSet<>(superset);
          result.removeAll(subset);
          return result;
      }
      //并集中，不在交集中的元素
      public static <T> Set<T> complement(Set<T> a, Set<T> b) {
          return difference(union(a, b), intersection(a, b));
      }
  }
  ```

- 引入`EnumSet`测试该工具类

  ```java
  public enum Watercolors {
      ZINC, LEMON_YELLOW, MEDIUM_YELLOW, DEEP_YELLOW,
      ORANGE, BRILLIANT_RED, CRIMSON, MAGENTA,
      ROSE_MADDER, VIOLET, CERULEAN_BLUE_HUE,
      PHTHALO_BLUE, ULTRAMARINE, COBALT_BLUE_HUE,
      PERMANENT_GREEN, VIRIDIAN_HUE, SAP_GREEN,
      YELLOW_OCHRE, BURNT_SIENNA, RAW_UMBER,
      BURNT_UMBER, PAYNES_GRAY, IVORY_BLACK
  }
  
  import static com.chapter20.generics.g_simplifyingtupleuse.Sets.*;
  import static com.chapter20.generics.g_simplifyingtupleuse.Watercolors.*;
  
  public class WatercolorSets {
      public static void main(String[] args) {
          Set<Watercolors> set1 = EnumSet.range(BRILLIANT_RED, VIRIDIAN_HUE);
          Set<Watercolors> set2 = EnumSet.range(CERULEAN_BLUE_HUE, BURNT_UMBER);
          System.out.println("set1: " + set1);
          System.out.println("set2: " + set2);
          System.out.println(
                  "union(set1, set2): " + union(set1, set2));
          Set<Watercolors> subset = intersection(set1, set2);
          System.out.println(
                  "intersection(set1, set2): " + subset);
          System.out.println("difference(set1, subset): " +
                  difference(set1, subset));
          System.out.println("difference(set2, subset): " +
                  difference(set2, subset));
          System.out.println("complement(set1, set2): " +
                  complement(set1, set2));
      }
  }
  ```

- `Sets.difference()` 方法来展示 **java.util** 包中各种 **Collection** 和 **Map** 类之间的方法差异

  ```java
  public class CollectionMethodDifferences {
      static Set<String> methodSet(Class<?> type) {
          return Arrays.stream(type.getMethods())
                  .map(Method::getName)
                  .collect(Collectors.toCollection(TreeSet::new));
      }
      static void interfaces(Class<?> type) {
          System.out.print("Interface in " + type.getSimpleName() + ": ");
          System.out.println(Arrays.stream(type.getInterfaces())
                  .map(Class::getSimpleName)
                  .collect(Collectors.toList()));
      }
      static Set<String> object = methodSet(Object.class);
      static {
          object.add("clone");
      }
      static void difference(Class<?> superset,Class<?> subset){
          System.out.print(superset.getSimpleName()+
                  " extends " + subset.getSimpleName()+", adds: ");
          Set<String> comp = Sets.difference(methodSet(superset),methodSet(subset));
          comp.removeAll(object);// Ignore 'Object' methods
          System.out.println(comp);
          interfaces(superset);
      }
      public static void main(String[] args) {
          System.out.println("Collection: " + methodSet(Collection.class));
          interfaces(Collection.class);
          difference(Set.class,Collection.class);
          difference(HashSet.class,Set.class);
          difference(LinkedHashSet.class, HashSet.class);
          difference(TreeSet.class, Set.class);
          difference(List.class, Collection.class);
          difference(ArrayList.class, List.class);
          difference(LinkedList.class, List.class);
          difference(Queue.class, Collection.class);
          difference(PriorityQueue.class, Queue.class);
          System.out.println("Map: " + methodSet(Map.class));
          difference(HashMap.class, Map.class);
          difference(LinkedHashMap.class, HashMap.class);
          difference(SortedMap.class, Map.class);
          difference(TreeMap.class, Map.class);
      }
  }
  
  ```

## 构建复杂模型

- **Mode**:简单且安全地构建模型

  ```java
  public class TupleList<A,B,C,D> extends ArrayList<Tuple4<A,B,C,D>> {
      public static void main(String[] args) {
          TupleList<Vehicle, Amphibian,String,Integer> tl  =new TupleList<>();
          tl.add(TupleTest2.h());
          tl.add(TupleTest2.h());
          tl.forEach(System.out::println);
      }
  }
  ```

- 下面是第二个例子。每个类都是组成块，总体包含很多个块。在这里，该模型是一个具有过道，货架和产品的零售商店：

  ```java
  public class Product {
      private final int id;
      private String description;
      private double price;
      public Product(int id, String description, double price) {
          this.id = id;
          this.description = description;
          this.price = price;
          System.out.println(toString());
      }
      @Override
      public String toString() {
          return id + ": " + description +
                  ", price: $" + price;
      }
      public void priceChange(double change) {
          price += change;
      }
      public static Supplier<Product> generator = new Supplier<Product>() {
          private Random rand = new Random(47);
          @Override
          public Product get() {
              return new Product(rand.nextInt(1000), "Test",
                      Math.round(rand.nextDouble() * 1000.0) + 0.99);
          }
      };
  }
  class Shelf extends ArrayList<Product> {
      Shelf(int nProducts) {
          Suppliers.fill(this, Product.generator, nProducts);
      }
  }
  class Aisle extends ArrayList<Shelf> {
      Aisle(int nShelves, int nProducts) {
          for (int i = 0; i < nShelves; i++)
              add(new Shelf(nProducts));
      }
  }
  class CheckoutStand {}
  class Office {}
  public class Suppliers {
      // Create a collection and fill it
      public static <T, C extends Collection<T>> C
      create(Supplier<C> factory, Supplier<T> gen, int n) {
          return Stream.generate(gen).limit(n).collect(factory, C::add, C::addAll);
      }
      // Fill an existing collection
      public static <T, C extends Collection> C fill(C coll, Supplier<T> gen, int n) {
          Stream.generate(gen).limit(n).forEach(coll::add);
          return coll;
      }
      //Use an unbound method reference to produce a more general method
      public static <H, A> H fill(H holder, BiConsumer<H, A> addr, Supplier<A> gen, int n) {
          Stream.generate(gen).limit(n).forEach(a -> addr.accept(holder, a));
          return holder;
      }
  }
  public class Store extends ArrayList<Aisle> {
      private ArrayList<CheckoutStand> checkouts =
              new ArrayList<>();
      private Office office = new Office();
      public Store(int nAisles, int nShelves, int nProducts) {
          for (int i = 0; i < nAisles; i++)
              add(new Aisle(nShelves, nProducts));
      }
  
      @Override
      public String toString() {
          StringBuilder result = new StringBuilder();
          for (Aisle a : this) {
              for (Shelf s : a) {
                  for (Product p : s) {
                      result.append(p);
                      result.append("\n");
                  }
              }
          }
          return result.toString();
      }
      public static void main(String[] args) {
          System.out.println(new Store(5, 4, 3));
      }
  }
  ```

## 泛型擦拭

- `ArrayList.class`才有意义，而`ArrayList<Integer>.class`没有意义  

  ```java
  public class ErasedTypeEquivalence {
      public static void main(String[] args) {
          Class c1 = new ArrayList<String>().getClass();
          Class c2 = new ArrayList<Integer>().getClass();
          System.out.println(c1==c2);
      }
  }
  // output
  true
  ```

  上例的程序认为`ArrayList<String>.class`跟`ArrayList<Integer>.class`是相同的类型。

  ```java
  public class LostInformation {
      public static void main(String[] args) {
          List list = new ArrayList<>();
          HashMap<Frob, Fnorkle> map = new HashMap<>();
          Quark<Fnorkle> quark = new Quark<>();
          Particle<Long, Double> p = new Particle<>();
          System.out.println(Arrays.toString(list.getClass().getTypeParameters()));
          System.out.println(Arrays.toString(map.getClass().getTypeParameters()));
          System.out.println(Arrays.toString(quark.getClass().getTypeParameters()));
          System.out.println(Arrays.toString(p.getClass().getTypeParameters()));
      }
  }
  class Frob {}
  class Fnorkle {}
  class Quark<Q> {}
  class Particle<POSITION, MOMENTUM> {}
  
  // output
  [E]
  [K, V]
  [Q]
  [POSITION, MOMENTUM]
  ```

  根据 JDK 文档，`Class.getTypeParameters()` “返回一个 `TypeVariable `对象数组，表示泛型声明中声明的类型参数...” 。而从输出结果看出，只能看到用作参数占位符的标识符这一没有意义的信息。

- 在泛型代码内部，无法获取任何有关泛型参数类型的信息。无法得知实际的类型参数。Java 泛型是使用擦除实现的。`List<String>`跟`List<Integer>`在运行时是相同类型`List`。

- 擦拭演变：C++方式 到没有边界再到使用边界

  ```c++
  #include <iostream>
  using namespace std;
  
  template<class T> class Manipulator {
      T obj;
  public:
      Manipulator(T x) { obj = x; }
      void manipulate() { obj.f(); }
  };
  
  class HasF {
  public:
      void f() { cout << "HasF::f()" << endl; }
  };
  
  int main() {
      HasF hf;
      Manipulator<HasF> manipulator(hf);
      manipulator.manipulate();
  }
  ```

  如果用***java***实现上述案例：

  ```java
  public class HasF {
      public void f() {
          System.out.println("HasF.f()");
      }
  }
  public class Manipulation {
      public static void main(String[] args) {
          HasF hf = new HasF();
          Manipulator<HasF> manipulator =
                  new Manipulator<>(hf);
          manipulator.manipulate();
      }
  }
  
  class Manipulator<T>{
      private T obj;
      Manipulator(T x) { obj = x; }
      // Error: cannot find symbol: method f():
      public void manipulate(){
          obj.f();
      }
  }
  ```

  很明显，是没法通过编译的。因为擦除，Java 编译器无法将 `manipulate()` 方法必须能调用` obj` 的 `f()` 方法这一需求映射到 `HasF `具有 `f()` 方法这个事实上。解决这个问题，可以使用边界。

  ```java
  class Manipulator2<T extends HasF>{
      private T obj;
    Manipulator(T x) { obj = x; }
      public void manipulate(){
          obj.f();
      }
  }
  ```
  
  泛型类型参数会擦除到它的第一个边界(可能有多个边界).`Manipulator2`中，`T` 擦除到了 `HasF`，就像在类的声明中用 `HasF` 替换了` T` 一样。那为什么还需要泛型呢?
  
  ```java
  class Manipulator3 {
      private HasF obj;
      Manipulator3(HasF x) {
          obj = x;
      }
      public void manipulate() {
          obj.f();
      }
  }
  ```
  
  这提出了很重要的一点:**泛型只有在类型参数比某个具体类型（以及其子类）更加“泛化”——代码能跨多个类工作时才有用**。当然不能简单地认为格式`<T extends HasF>`是 有缺陷的。如如果某个类有一个返回 **T** 的方法，那么泛型就有所帮助
  
  ```java
  public class ReturnGenericType<T extends HasF> {
      private T obj;
      public ReturnGenericType(T obj) {
          this.obj = obj;
      }
      public T get(){
          return obj;
      }
  }
  ```

- 擦除使得这种向泛型的迁移成为可能，允许非泛型的代码和泛型代码共存。擦除主要的正当理由是从非泛化代码到泛化代码的转变过程，以及在不破坏现有类库的情况下将泛型融入到语言中

- 泛型不能用于显式地引用运行时类型的操作中，例如转型、`instanceof` 操作和 `new`表达式。因为所有关于参数的类型信息都丢失了。使用泛型并不是强制的

  ```java
  public class ErasureAndInheritance {
      public static void main(String[] args) {
          Derived2 derived2 = new Derived2();
          Object obj = derived2.get();
          derived2.set(obj); // Warning hear
      }
  }
  class GenericBase<T>{
      private T element;
      public void set(T arg){
          element = arg;
      }
      public T get(){return element;}
  }
  class Derived1<T> extends GenericBase<T>{}
  class Derived2<T> extends GenericBase{} // No warning
  //class Derived3 extends GenericBase<?> {}
  
  ```

  `Derived2`继承自` GenericBase`，但是没有任何类型参数，编译器没有发出任何警告。直到调用 `set()` 方法时才出现警告。

  当你希望将类型参数不仅仅当作 Object 处理时，就需要付出额外努力来管理边界。

## The Action at the Boundaries  

- 泛型还有一缺陷是竟然可以表示没有意义的事务：

  ```java
  public class ArrayMaker<T> {
      private Class<T> kind;
      public ArrayMaker(Class<T> kind) {
          this.kind = kind;
      }
      public T[] create(int size) {
          @SuppressWarnings("unchecked") T[] result = 
                  (T[]) Array.newInstance(kind, size);
          return result;
      }
  }
  ```

  `Array.newInstance`方法返回`Object`(或者说这里就不应该返回`Object`而应该返回`kind`类型的数组)，强制类型转换后出现警告:`Unchecked cast:'java.lang.Object' to 'T[]'`。这说明，`Array.newInstance`方法并不真正地拥有类型`kind`。(可以使用`@SuppressWarnings("unchecked")`来消除警告，不过该警告应该尽可能小范围使用--Effective java)。

  ```java
  public class Suppliers {
      // Create a collection and fill it
      public static <T, C extends Collection<T>> C
      create(Supplier<C> factory, Supplier<T> gen, int n) {
          return Stream.generate(gen).limit(n).collect(factory, C::add, C::addAll);
      }
      // Fill an existing collection
      public static <T, C extends Collection> C fill(C coll, Supplier<T> gen, int n) {
          Stream.generate(gen).limit(n).forEach(coll::add);
          return coll;
      }
      //Use an unbound method reference to produce a more general method
      public static <H, A> H fill(H holder, BiConsumer<H, A> addr, Supplier<A> gen, int n) {
          Stream.generate(gen).limit(n).forEach(a -> addr.accept(holder, a));
          return holder;
      }
  }
  public class FilledList<T> extends ArrayList<T> {
      FilledList(Supplier<T> gen,int size){
          Suppliers.fill(this,gen,size);
      }
      public FilledList(T t,int size){
          for (int i = 0; i < size; i++) {
              this.add(t);
          }
      }
      public static void main(String[] args) {
          List<String> list = new FilledList<>("Hello", 4);
          System.out.println(list);
          List<Integer> ilist = new FilledList<>(() -> 47, 4);
          System.out.println(ilist);
      }
  }
  ```

  编译器无法得知 `add()` 中的 **T** 的任何信息，但它仍可以在编译期确保你放入 `FilledList`中的对象是 **T** 类型。因此，即使擦除移除了方法或类中的实际类型的信息，编译器仍可以确保方法或类中使用的类型的内部一致性。

- 边界动作

  ```java
  public class SimpleHolder {
      private Object obj;
      public void set(Object obj) {
          this.obj = obj;
      }
      public Object get() {
          return obj;
      }
      public static void main(String[] args) {
          SimpleHolder holder = new SimpleHolder();
          holder.set("Item");
          String s = (String) holder.get();
      }
  }
  ```

  使用***javap -c SimpleHolder***反编译：

  ```java
  public void set(java.lang.Object);
     0: aload_0
     1: aload_1
     2: putfield #2; // Field obj:Object;
     5: return
      
  public java.lang.Object get();
     0: aload_0
     1: getfield #2; // Field obj:Object;
     4: areturn
      
  public static void main(java.lang.String[]);
     0: new #3; // class SimpleHolder
     3: dup
     4: invokespecial #4; // Method "<init>":()V
     7: astore_1
     8: aload_1
     9: ldc #5; // String Item
     11: invokevirtual #6; // Method set:(Object;)V
     14: aload_1
     15: invokevirtual #7; // Method get:()Object;
     18: checkcast #8; // class java/lang/String
     21: astore_2
     22: return
  ```

  在调用 `get()` 时接受检查转型。接下来使用泛型和反编译结果：

  ```java
  public class GenericHolder2<T> {
      private T obj;
      public void set(T obj){
          this.obj = obj;
      }
      public T get(){
          return obj;
      }
      public static void main(String[] args) {
          GenericHolder2<String> holder = new GenericHolder2<>();
          holder.set("item");
          String item = holder.get();
      }
  }
  public void set(java.lang.Object);
     0: aload_0
     1: aload_1
     2: putfield #2; // Field obj:Object;
     5: return
         
  public java.lang.Object get();
     0: aload_0
     1: getfield #2; // Field obj:Object;
     4: areturn
         
  public static void main(java.lang.String[]);
     0: new #3; // class GenericHolder2
     3: dup
     4: invokespecial #4; // Method "<init>":()V
     7: astore_1
     8: aload_1
     9: ldc #5; // String Item
     11: invokevirtual #6; // Method set:(Object;)V
     14: aload_1
     15: invokevirtual #7; // Method get:()Object;
     18: checkcast #8; // class java/lang/String
     21: astore_2
     22: return
  ```

  上面可以看出，使用泛型跟不使用泛型产生的字节码文件都是一样的。使用泛型，调用`get()`方法时，编译器自动插入了类型转换。这个告诉我们，泛型的所有动作发生在边界处——对入参的编译器检查和对返回值的转型。

## 补偿擦拭

- 泛型擦拭问题示例：

  ```java
  public class Erased<T> {
      private final int SIZE = 100;
      public void f(Object arg){
          // error: illegal generic type of instanceof
          if (arg instanceof T) {}
          // error:unexpected type
          T var = new T();
          // error: generic array creation
          T[] array = new T[SIZE];
          // warning: [unchecked] unchecked cast
          T[] arr = (T[])new Object[SIZE];
      }
  }
  ```

- 有一些补偿机制解决上例问题，如`isInstance`补偿`instanceof`

  ```java
  public class ClassTypeCapture<T> {
      Class<T> kind;
      public ClassTypeCapture(Class<T> kind) {
          this.kind = kind;
      }
      public boolean isInstance(Object arg) {
          return kind.isInstance(arg);
      }
      public static void main(String[] args) {
          ClassTypeCapture<Building> btc = new ClassTypeCapture<>(Building.class);
          System.out.println(btc.isInstance(new Building()));
          System.out.println(btc.isInstance(new House()));
          ClassTypeCapture<House> ctt =
                  new ClassTypeCapture<>(House.class);
          System.out.println(ctt.isInstance(new Building()));
          System.out.println(ctt.isInstance((new House())));
      }
  }
  class Building {
  }
  class House extends Building {
  }
  ```
  
- 补偿 `new T()`:传入一个工厂对象，并使用该对象创建新实例

  ```java
  public class InstantiateGenericType {
      public static void main(String[] args) {
          ClassAsFactory<Employee> fe = new ClassAsFactory<>(Employee.class);
          System.out.println(fe.get());
          ClassAsFactory<Integer> fi =
                  new ClassAsFactory<>(Integer.class);
          try {
              System.out.println(fi.get());
          } catch (Exception e) {
              System.out.println(e.getMessage());
          }
      }
  }
  class Employee {
      @Override
      public String toString() {
          return "Employee";
      }
  }
  class ClassAsFactory<T> implements Supplier<T>{
      private Class<T> kind;
      ClassAsFactory(Class<T> kind) {
          this.kind = kind;
      }
      @Override
      public T get() {
          try {
              return kind.newInstance();
          } catch (InstantiationException|IllegalAccessException e) {
            throw new RuntimeException(e);
          }
      }
  }
  // output
  /**
   * Employee
   * java.lang.InstantiationException: java.lang.Integer
   */
  ```

  由于`Integer`中没有无参构造方法，`ClassAsFactory<Integer> `执行失败。语言创建者不赞成这种方法。他们建议使用显式工厂（**Supplier**）

  ```java
  public class FactoryConstraint {
      public static void main(String[] args) {
          System.out.println(new Foo2<>(new IntegerFactory()));
          System.out.println(new Foo2<>(new Widget.Factory()));
          System.out.println(new Foo2<>(Fudge::new));
      }
  }
  class IntegerFactory implements Supplier<Integer>{
      private int i;
      @Override
      public Integer get() {
          return ++i;
      }
  }
  class Widget{
      private int id;
      public Widget(int id) {
          this.id = id;
      }
      @Override
      public String toString() {
          return "Widget " + id;
      }
      public static class Factory implements Supplier<Widget>{
          private int i = 0;
          @Override
          public Widget get() {
              return new Widget(++i);
          }
      }
  }
  class Fudge{
      private static int count = 1;
      private int n = count++;
      @Override
      public String toString() {
          return "Fudge " + n;
      }
  }
  class Foo2<T>{
      private List<T> x = new ArrayList<>();
      Foo2(Supplier<T> factory) {
          Suppliers.fill(x, factory, 5);
      }
      @Override
      public String toString() {
          return x.toString();
      }
  }
  ```

  `IntegerFactory`本身就是通过实现 `Supplier` 的工厂。 `Widget` 包含一个内部类，它是一个工厂。还要注意，`Fudge`并没有做任何类似于工厂的操作，并且传递 `Fudge::new` 仍然会产生工厂行为，因为编译器将对函数方法 `::new` 的调用转换为对 `get()` 的调用。

- 模板方法模式实现工厂

  ```java
  public abstract class GenericWithCreate<T> {
       final T element;
      public GenericWithCreate() {
          element = create();
      }
      abstract T create();
  }
  class  X{}
  class XCreator extends GenericWithCreate<X>{
      @Override
      X create() {
          return new X();
      }
      void f(){
          System.out.println(element.getClass().getSimpleName());
      }
  }
  public class CreatorGeneric {
      public static void main(String[] args) {
          XCreator xc = new XCreator();
          xc.f();
      }
  }
  ```

- 泛型数组，先看第一个类型转换失败例子:

  创建一个`Object`类型的数组，然后转换成想要类型的数组

  ```java
  public class ArrayOfGeneric {
      static final int SIZE = 100;
      static Generic<Integer>[] gia;
  
      public static void main(String[] args) {
          try {
              gia = (Generic<Integer>[]) new Object[SIZE];
          } catch (ClassCastException e) {
              System.out.println(e.getMessage());
          }
          // Runtime type is the raw (erased) type:
          gia = (Generic<Integer>[]) new Generic[SIZE];
          System.out.println(gia.getClass().getSimpleName());
          gia[0] = new Generic<>();
          // gia[1] = new Object(); // Compile-time error
          //gia[2] = new Generic<Double>();
      }
  }
  class Generic<T> {
  }
  /* Output:
  [Ljava.lang.Object; cannot be cast to [LGeneric;
  Generic[]
  */
  ```

  成功创建泛型类型的数组的唯一方法是创建一个已擦除类型的新数组，并将其强制转换。

  ```java
  public class GenericArray<T> {
      private T[] array;
      @SuppressWarnings("unchecked")
      public GenericArray(int sz) {
          array = (T[]) new Object[sz];
      }
      public void put(int index, T item) {
          array[index] = item;
      }
      public T get(int index) {
          return array[index];
      }
      // Method that exposes the underlying representation:
      public T[] rep() {
          return array;
      }
      public static void main(String[] args) {
          GenericArray<Integer> gai = new GenericArray<>(10);
          try {
              Integer[] ia = gai.rep();
          } catch (ClassCastException e) {
              System.out.println(e.getMessage());
          }
          // This is OK:
          Object[] oa = gai.rep();
      }
  }
  /* Output:
  [Ljava.lang.Object; cannot be cast to
  [Ljava.lang.Integer;
  */
  ```

  和以前一样，我们不能说 `T[] array = new T[sz]` ，所以我们创建了一个 **Object** 数组并将其强制转换。

  `rep()` 方法返回一个 `T[]` ，在主方法中它应该是 `gai` 的 `Integer[]`，但是如果调用它并尝试将结果转换为 `Integer[]` 引用，则会得到 **ClassCastException** ，这再次是因为实际的运行时类型为 `Object[]` 。***由于擦除，数组的运行时类型只能是*** `Object[]`。

  ```java
  public class GenericArray2<T> {
      private Object[] array;
      public GenericArray2(int size) {
          array = new Object[size];
      }
      public void put(int index, T item) {
          array[index] = item;
      }
      @SuppressWarnings("unchecked")
      public T get(int index) {
          return (T) array[index];// this is safe
      }
      @SuppressWarnings("unchecked")
      public T[] rep() {
          return (T[]) array; // Unchecked cast
      }
      public static void main(String[] args) {
          GenericArray2<Integer> gai = new GenericArray2<>(10);
          for (int i = 0; i < 10; i++)
              gai.put(i, i);
          for (int i = 0; i < 10; i++)
              System.out.print(gai.get(i) + " ");
          System.out.println();
          try {
              Integer[] ia = gai.rep();
          } catch (Exception e) {
              System.out.println(e);
          }
      }
  }
  ```

  无法破坏基础数组的类型，该基础数组只能是 `Object[]` 。在内部将数组视为 `Object[]` 而不是 `T[]` 的优点是，我们不太可能会忘记数组的运行时类型并意外地引入了bug，尽管大多数（也许是全部）此类错误会在运行时被迅速检测到。对于新代码：

  ```java
  public class GenericArrayWithTypeToken<T> {
      private T[] array;
      @SuppressWarnings("unchecked")
      public GenericArrayWithTypeToken(Class<T> type,int size){
          array = (T[]) Array.newInstance(type,size);
      }
      public void put(int index, T item) {
          array[index] = item;
      }
      public T get(int index) { return array[index]; }
      // Expose the underlying representation:
      public T[] rep() { return array; }
  
      public static void main(String[] args) {
          GenericArrayWithTypeToken<Integer> gai =
                  new GenericArrayWithTypeToken<>(Integer.class, 10);
          // This now works:
          Integer[] ia = gai.rep();
          System.out.println(ia);
      }
  }
  ```

## 边界

- 边界允许我们对泛型使用的参数类型施加约束，可以在绑定的类型中调用方法。`extends`定义了上边界，`super`定义了下边界。

  基础用法：

  ```java
  public class BasicBounds {
      public static void main(String[] args) {
          Solid<Bounded> solid = new Solid<>(new Bounded());
          solid.color();
          solid.getY();
          solid.getItem();
      }
  }
  
  interface HasColor {
      Color getColor();
  }
  
  class WithColor<T extends HasColor> {
      T item;
      public WithColor(T item) {
          this.item = item;
      }
      T getItem(){
          return item;
      }
      Color color(){
          return item.getColor();
      }
  }
  class Coord{
      public int x,y,z;
  }
  //This fails,Class must be first,then interface
  //class WithColorCoord<T extends HasColor & Coord> {}
  class  WithColorCoord<T extends Coord & HasColor> {
      T item;
      WithColorCoord(T item){
          this.item = item;
      }
      T getItem(){
          return item;
      }
      Color color(){
          return item.getColor();
      }
      int getX() { return item.x; }
      int getY() { return item.y; }
      int getZ() { return item.z; }
  }
  interface Weight{
      int weight();
  }
  //you can have only one
  // concrete class but multiple interfaces:
  class Solid<T extends Coord & HasColor & Weight>{
      T item;
      Solid(T item) { this.item = item; }
      T getItem() { return item; }
      java.awt.Color color() { return item.getColor(); }
      int getX() { return item.x; }
      int getY() { return item.y; }
      int getZ() { return item.z; }
      int weight() { return item.weight(); }
  }
  class Bounded extends Coord implements HasColor,Weight{
      @Override
      public Color getColor() {
          return null;
      }
      @Override
      public int weight() {
          return 0;
      }
  }
  ```

## 通配符

- 通配符：泛型表达式中的问号。

  先来看使用数组的一些约束

  ```java
  public class CovariantArrays {
      public static void main(String[] args) {
          Fruit[] fruit = new Apple[10];
          fruit[0] = new Apple();
          fruit[1] = new Jonathan();
          // Runtime type is Apple[], not Fruit[] or Orange[]:
          try {
              fruit[0] = new Fruit();
          } catch (Exception e) {
              System.out.println(e);
          }
          try {
              // Compiler allows you to add Oranges:
              fruit[0] = new Orange(); // ArrayStoreException
          } catch (Exception e) {
              System.out.println(e);
          }
      }
  }
  
  class Fruit {
  }
  class Apple extends Fruit {
  }
  class Jonathan extends Apple {
  }
  class Orange extends Fruit {
  }
  
  ```

  改用集合代替数组

  ```java
  public class NonCovariantGenerics {
      // // Compile Error: incompatible types:
      ArrayList<Fruit> flist = new ArrayList<Apple>();
  }
  ```

  这里不通过编译是因为，虽然`Apple`是`Fruite`的子类型，但是`ArrayList<Apple>`并不是`ArrayList<Fruite>`的子类型。

  但是，有时你想在两个类型间建立某种向上转型关系。通配符可以产生这种关系。

  ```java
  public class NonCovariantGenerics {
      public static void main(String[] args) {
          List<? extends Fruit> fruits = new ArrayList<>();
          // Compile Error: can't add any type of object:
  //         fruits.add(new Apple());
          // fruits.add(new Fruit());
          // fruits.add(new Object());
          fruits.add(null); // Legal but uninteresting
          fruits.indexOf(new Apple());
          Fruit f = fruits.get(0);
      }
  }
  ```

  `List<? extends Fruit> fruits`可以读做：一个继承自`Fruit`类型的列表。但并不是指这个列表可以持有任何类型的`Fruit`。**为什么上例中调`add()`方法会添加失败呢？**。查看`ArrayList`文档可知，`add`方法接收类型为`E`在这里也就是`? extends Fruit`，由于编译器无法得知这里需要 **Fruit** 的哪个具体子类型，因此拒绝接收任何类型的`Fruit`。而`indexof`方法接收的是`Object`类型，故编译通过。这意味着将由泛型类的设计者来决定哪些调用是“安全的”，并使用 **Object** 类作为它们的参数类型。

  ```java
  public class Holder<T> {
      private T value;
      public Holder(){}
      public Holder(T val){
          value = val;
      }
      public T get() {
          return value;
      }
      public void set(T value) {
          this.value = value;
      }
      @Override
      public boolean equals(Object o) {
          return o instanceof Holder && Objects.equals(value, ((Holder) o).value);
      }
      @Override
      public int hashCode() {
          return Objects.hashCode(value);
      }
      public static void main(String[] args) {
          Holder<Apple> appleHolder = new Holder<>(new Apple());
          Apple apple = appleHolder.get();
          appleHolder.set(apple);
          //Holder<Fruit> fruitHolder = appleHolder;// Cannot upcast
          Holder<? extends Fruit> fruitHolder = appleHolder;// ok
          Fruit fruit = fruitHolder.get();
          apple = (Apple)fruitHolder.get();
          try{
              Orange c = (Orange) fruitHolder.get();// no warning
          }catch (Exception e){
              System.out.println(e);
          }
  //        fruit.set(new Apple()); // Cannot call set()
  //        fruit.set(new Fruit()); // Cannot call set()
          System.out.println(fruitHolder.equals(apple)); // OK
      }
  }
  ```

- 超类型通配符

  `<? super MyClass>`:由某个特定类的任何基类来界定

  ```java
  public class SuperTypeWildcards {
      static void writeTo(List<? super Apple> apples) {
          apples.add(new Apple());
          apples.add(new Jonathan());
          // apples.add(new Fruit()); // Error
      }
  }
  ```

  参数 **apples** 是 **Apple** 的某种基类型的 **List**，这样你就知道向其中添加 **Apple** 或 **Apple** 的子类型是安全的。因为 **Apple** 是下界，所以你知道向这样的 **List** 中添加 **Fruit** 是不安全的，因为这将使这个 **List** 敞开口子，从而可以向其中添加非 **Apple** 类型的对象，而这是违反静态类型安全的。

  ```java
  public class GenericReading {
      static List<Apple> apples = Arrays.asList(new Apple());
      static List<Fruit> fruit = Arrays.asList(new Fruit());
      static <T> T readExact(List<T> list){
          return list.get(0);
      }
      static void f1(){
          Apple apple = readExact(apples);
          Fruit fruit = readExact(GenericReading.fruit);
          fruit = readExact(apples);
      }
  
      static class Reader<T>{
          T readExact(List<T> list){
              return list.get(0);
          }
      }
      static void f2(){
          Reader<Fruit> fruitReader = new Reader<>();
          Fruit f = fruitReader.readExact(fruit);
          // error: incompatible types: List<Apple> cannot be converted to List<Fruit>
          // fruitReader.readExact(apples);
      }
      static class CovariantReader<T>{
          T readCovariant(List<? extends T> list){
              return list.get(0);
          }
      }
      static void f3(){
          CovariantReader<Fruit> covariantReader = new CovariantReader<>();
          Fruit fruit = covariantReader.readCovariant(GenericReading.fruit);
          Fruit a = covariantReader.readCovariant(apples);
  
      }
      public static void main(String[] args) {
          f1();
          f2();
          f3();
      }
  }
  
  ```

  对于泛型类来说，当你创建这个类的实例时，就要为这个类确定参数。就像在 `f2()` 中看到的，`fruitReader` 实例可以从 `List` 中读取一个 `Fruit` ，因为这就是它的确切类型。但此时它却不能接受`apples`。 为了修正这个问题，`CovariantReader.readCovariant()` 方法将接受 `List<?extends T>` 。

- `<? extends T> `跟`<? super T>`差异总结

  ```java
  private void clientMethod(){
          List<Fruit> fruits = new ArrayList<>();
          extendsTest(fruits);
          List<Apple> apples = new ArrayList<>();
          extendsTest(apples);
          List<Orange> oranges = new ArrayList<>();
          extendsTest(oranges);
          List<Object> objects = new ArrayList<>();
          extendsTest(objects); // error:can not applied
  
          superTest(fruits);
          superTest(apples); // error
          superTest(oranges); // error
          superTest(objects);
      }
  	// 定义了下界，赋值时可以赋值子类型，而不能添加任何类型。因为不确定会有哪个子类型赋值，
  	//为保证安全不允许添加
      private void extendsTest(List<? extends Fruit> fruits){
          fruits.add(new Apple()); //error: can not applied
          fruits.add(new Fruit()); // error
          fruits.add(new Orange());// error
          fruits.add(new Object());// error
          fruits.add(null);
      }
  	// super 定义了下界，只能向其中添加子类型。赋值时，只能赋值自身跟父类型
      private void superTest(List<? super Fruit> fruits){
          fruits.add(new Apple()); 
          fruits.add(new Fruit());
          fruits.add(new Orange());
          fruits.add(new Object()); // error
          fruits.add(null);
      }
  }
  ```

- 无界通配符

  无界通配符`<?>`跟原生类型并不一样：

  ```java
  public class UnboundedWildcards1 {
      static List list1;
      static List<?> list2;
      static List<? extends Object> list3;
  
      static void assign1(List list){
          list1 = list;
          list2 = list;
          // warning: [unchecked] unchecked conversion
          list3 = list;
      }
      static void assign2(List<?> list){
          list1 = list;
          list2 = list;
          list3 = list;
      }
      static void assign3(List<? extends Object> list){
          list1 =list;
          list2 =list;
          list3 =list;
      }
  
      public static void main(String[] args) {
          assign1(new ArrayList());
          assign2(new ArrayList());
          assign3(new ArrayList());// warning:uncheck assign
          assign1(new ArrayList<>());
          assign2(new ArrayList<>());
          assign3(new ArrayList<>());
          List<?> wildList = new ArrayList();
          wildList = new ArrayList<>();
          assign1(wildList);
          assign2(wildList);
          assign3(wildList);
      }
  }
  ```

  `<?>`在这里的意思是：“我是想用 Java 的泛型来编写这段代码，我在这里并不是要用原生类型，但是在当前这种情况下，泛型参数可以持有任何类型。”看第二个实示例：

## 泛型异常

- 由于擦除的原因，**catch** 语句不能捕获泛型类型的异常。泛型类也不能直接或间接继承自 **Throwable**（这将进一步阻止你去定义不能捕获的泛型异常）。 但是，类型参数可能会在一个方法的 **throws** 子句中用到。这使得你可以编写随检查型异常类型变化的泛型代码：

  ```java
  public class ThrowGenericException {
      public static void main(String[] args) {
          ProcessRunner<String, Failure1> runner = new ProcessRunner<>();
          for (int i = 0; i < 3; i++) {
              runner.add(new Processor1());
          }
          try {
              System.out.println(runner.processAll());
          } catch (Failure1 failure1) {
              System.out.println(failure1);
          }
          ProcessRunner<Integer, Failure2> runner2 =
                  new ProcessRunner<>();
          for(int i = 0; i < 3; i++)
              runner2.add(new Processor2());
          try {
              System.out.println(runner2.processAll());
          } catch(Failure2 e) {
              System.out.println(e);
          }
      }
  }
  
  interface Processor<T,E extends Exception>{
      void process(List<T> resultCollector) throws E;
  }
  class ProcessRunner<T,E extends Exception> extends
          ArrayList<Processor<T,E>>{
      List<T> processAll() throws E{
          List<T> resultCollector = new ArrayList<>();
          for (Processor<T, E> processor : this) {
              processor.process(resultCollector);
          }
          return resultCollector;
      }
  }
  class Failure1 extends Exception{}
  
  class Processor1 implements Processor<String,Failure1>{
      static int count =3;
      @Override
      public void process(List<String> resultCollector) throws Failure1 {
          if(count-- > 1)
              resultCollector.add("Hep!");
          else
              resultCollector.add("Ho!");
          if(count < 0)
              throw new Failure1();
      }
  }
  class Failure2 extends Exception {}
  class Processor2 implements Processor<Integer,Failure2>{
      static int count = 2;
      @Override
      public void process(List<Integer> resultCollector) throws Failure2 {
          if(count-- == 0)
              resultCollector.add(47);
          else {
              resultCollector.add(11);
          }
          if(count < 0)
              throw new Failure2();
      }
  }
  ```

## 混型

- 概念：混合多个类的能力，以产生一个可以表示混型中所有类型的类。

  先看与接口混合的例子

  ```java
  public class Mixins {
      public static void main(String[] args) {
          Mixin mixin1 = new Mixin();
          Mixin mixin2 = new Mixin();
          mixin1.set("test string 1");
          mixin2.set("test string 2");
          System.out.println(mixin1.get() + " " +
                  mixin1.getStamp() +  " " + mixin1.getSerialNumber());
          System.out.println(mixin2.get() + " " +
                  mixin2.getStamp() +  " " + mixin2.getSerialNumber());
      }
  }
  
  interface TimeStamped {
      long getStamp();
  }
  class TimeStampedImp implements TimeStamped {
      private final long timeStamp;
      TimeStampedImp() {
          timeStamp = new Date().getTime();
      }
      @Override
      public long getStamp() {
          return timeStamp;
      }
  }
  interface SerialNumbered {
      long getSerialNumber();
  }
  class SerialNumberedImp implements SerialNumbered {
      private static long counter = 1;
      private final long serialNumber = counter++;
      @Override
      public long getSerialNumber() {
          return serialNumber;
      }
  }
  interface Basic {
      void set(String val);
      String get();
  }
  class BasicImp implements Basic {
      private String value;
      @Override
      public void set(String val) { value = val; }
      @Override
      public String get() { return value; }
  }
  class Mixin extends BasicImp implements TimeStamped,SerialNumbered{
      private TimeStamped timeStamp = new TimeStampedImp();
      private SerialNumbered serialNumber =
              new SerialNumberedImp();
      @Override
      public long getStamp() {
          return timeStamp.getStamp();
      }
      @Override
      public long getSerialNumber() {
          return serialNumber.getSerialNumber();
      }
  }
  ```

  可以看出，`Mixin`类使用的是委托。因此每个混入类型都要求在 **Mixin** 中有一个相应的域，而你必须在 **Mixin** 中编写所有必需的方法，将方法调用转发给恰当的对象。这个示例使用了非常简单的类，但是当使用更复杂的混型时，代码数量会急速增加。

- **装饰器**是通过使用组合和形式化结构（可装饰物/装饰器层次结构）来实现的，而混型是基于继承的。因此可以将基于参数化类型的混型当作是一种泛型装饰器机制，这种机制不需要装饰器设计模式的继承结构。 前面的示例可以被改写为使用装饰器

  ```java
  public class Decoration {
      public static void main(String[] args) {
          TimeStamped t = new TimeStamped(new Basic());
          TimeStamped t2 = new TimeStamped(new SerialNumbered(new Basic()));
          //- t2.getSerialNumber(); // Not available
          SerialNumbered s = new SerialNumbered(new Basic());
          SerialNumbered s2 = new SerialNumbered(
                  new TimeStamped(new Basic()));
          //- s2.getStamp(); // Not available
      }
  }
  class Basic{
      private String value;
      public void set(String val){
          this.value = val;
      }
      public String get() { return value; }
  }
  class Decorator extends Basic{
      protected Basic basic;
      public Decorator(Basic basic) {
          this.basic = basic;
      }
      @Override
      public void set(String val) {
          basic.set(val);
      }
      @Override
      public String get() {
          return basic.get();
      }
  }
  class TimeStamped extends Decorator{
      private final long timeStamp;
      public TimeStamped(Basic basic) {
          super(basic);
          timeStamp = new Date().getTime();
      }
      public long getStamp() { return timeStamp; }
  }
  class SerialNumbered extends Decorator{
      private static long counter = 1;
      private final long serialNumber = counter++;
      public SerialNumbered(Basic basic) {
          super(basic);
      }
      public long getSerialNumber() { return serialNumber; }
  }
  ```

  尽管可以添加多个层，但是最后一层才是实际的类型，因此只有最后一层的方法是可视的，而混型的类型是所有被混合到一起的类型。因此对于装饰器来说，其明显的缺陷是它只能有效地工作于装饰中的一层（最后一层），而混型方法显然会更自然一些。

- 与动态代理混合；使用动态代理来创建一种比装饰器更贴近混型模型的机制

  ```java
  public class DynamicProxyMixin {
      public static void main(String[] args) {
          Object mixin = MixinProxy.newInstance(
                  tuple(new BasicImp(), Basic.class),
                  tuple(new TimeStampedImp(), TimeStamped.class),
                  tuple(new SerialNumberedImp(), SerialNumbered.class));
          Basic b = (Basic)mixin;
          TimeStamped t = (TimeStamped)mixin;
          SerialNumbered s = (SerialNumbered)mixin;
          b.set("Hello");
          System.out.println(b.get());
          System.out.println(t.getStamp());
          System.out.println(s.getSerialNumber());
      }
  }
  class MixinProxy implements InvocationHandler{
      Map<String, Object> delegatesByMethod;
      MixinProxy(Tuple2<Object,Class<?>>... pairs){
          delegatesByMethod = new HashMap<>();
          for (Tuple2<Object, Class<?>> pair : pairs) {
              for (Method method : pair.b.getMethods()) {
                  String methodName = method.getName();
                  if(!delegatesByMethod.containsKey(methodName))
                      delegatesByMethod.put(methodName, pair.a);
              }
          }
      }
      @Override
      public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
          String methodName = method.getName();
          Object delegate = delegatesByMethod.get(methodName);
          return method.invoke(delegate, args);
      }
      public static Object newInstance(Tuple2... pairs){
          Class[] interfaces = new Class[pairs.length];
          for(int i = 0; i < pairs.length; i++) {
              interfaces[i] = (Class)pairs[i].b;
          }
          ClassLoader cl = pairs[0].a.getClass().getClassLoader();
          return Proxy.newProxyInstance(cl, interfaces, new MixinProxy(pairs));
      }
  
  }
  /* Output:
  Hello
  1494331653339
  1
  */
  ```

## 潜在类型机制

- 潜在类型机制是一种代码组织和复用机制。有了它，编写出的代码相对于没有它编写出的代码，能够更容易地复用。代码组织和复用是所有计算机编程的基本手段

  ```java
  public interface Performs {
      void speak();
      void sit();
  }
  class PerformingDog extends Dog implements Performs {
      @Override
      public void speak() { System.out.println("Woof!"); }
      @Override
      public void sit() { System.out.println("Sitting"); }
      public void reproduce() {}
  }
  class Robot implements Performs {
      public void speak() { System.out.println("Click!"); }
      public void sit() { System.out.println("Clank!"); }
      public void oilChange() {}
  }
  class Communicate {
      public static <T extends Performs> void perform(T performer){
          performer.speak();
          performer.sit();
      }
  }
  public class DogsAndRobots {
      public static void main(String[] args) {
          Communicate.perform(new PerformingDog());
          Communicate.perform(new Robot());
      }
  }
  /* Output:
  Woof!
  Sitting
  Click!
  Clank!
  */
  ```

  很明显，这个例子中方法`perform`不需要使用泛型了工作，它的参数可以直接指定`Performer`类型。因为是使用该方法的那些类已经强制实现了`Performer`接口。这就是**Java**直接支持潜在类型机制。但提供了补偿机制。

  反射：

  ```java
  public class LatentReflection {
      public static void main(String[] args) {
          CommunicateReflectively.perform(new SmartDog());
          CommunicateReflectively.perform(new Robot());
          CommunicateReflectively.perform(new Mime());
      }
  }
  // Does not implement Performs:
  class Mime{
      public void walkAgainstTheWind(){}
      public void sit() {
          System.out.println("Pretending to sit");
      }
      public void pushInvisibleWalls() {}
      @Override
      public String toString() { return "Mime"; }
  }
  class SmartDog{
      public void speak() { System.out.println("Woof!"); }
      public void sit() { System.out.println("Sitting"); }
      public void reproduce() {}
  }
  class CommunicateReflectively{
      public static void perform(Object speaker){
          Class<?> spkr = speaker.getClass();
          try {
              try {
                  Method speak = spkr.getMethod("speak");
                  speak.invoke(speaker);
              } catch(NoSuchMethodException e) {
                  System.out.println(speaker + " cannot speak");
              }
              try {
                  Method sit = spkr.getMethod("sit");
                  sit.invoke(speaker);
              } catch(NoSuchMethodException e) {
                  System.out.println(speaker + " cannot sit");
              }
          } catch(SecurityException |
                  IllegalAccessException |
                  IllegalArgumentException |
                  InvocationTargetException e) {
              throw new RuntimeException(speaker.toString(), e);
          }
  
      }
  }
  /* Output:
  Woof!
  Sitting
  Click!
  Clank!
  Mime cannot speak
  Pretending to sit
  */
  ```

  上例中，这些类完全是彼此分离的，没有任何公共基类（除了 **Object** ）或接口。通过反射, `CommunicateReflectively.perform()` 能够动态地确定所需要的方法是否可用并调用它们。

  但是反射存在缺陷它将所有的类型检查都转移到了运行时，因此在许多情况下并不是我们所希望的。如果能够实现编译期类型检查，这通常会更符合要求。

  假设有一个这样的场景：想要创建一个 `apply()` 方法，它能够将任何方法应用于某个序列中的所有对象。这种情况下使用接口不适合，因为你想要将任何方法应用于一个对象集合，而接口不可能描述任何方法。看使用反射来实现：

  ```java
  public class Apply {
      public static <T, S extends Iterable<T>> void apply(S seq, Method f,Object...  args){
          try {
              for(T t: seq)
                  f.invoke(t, args);
          } catch(IllegalAccessException |
                  IllegalArgumentException |
                  InvocationTargetException e) {
              // Failures are programmer errors
              throw new RuntimeException(e);
          }
      }
  }
  public class Shape {
      private static long counter = 0;
      private final  long id = counter++;
      @Override
      public String toString() {
          return getClass().getSimpleName()+ " " + id;
      }
      public void rotate(){
          System.out.println(this + " rotate");
      }
      public void resize(int newSize){
          System.out.println(this + " resize" + newSize);
      }
  }
  public class Square extends Shape {
  }
  public class FilledList<T> extends ArrayList<T> {
      public FilledList(Supplier<T> gen,int size){
          Suppliers.fill(this,gen,size);
      }
      public FilledList(T t,int size){
          for (int i = 0; i < size; i++) {
              this.add(t);
          }
      }
  }
  public class ApplyTest {
      public static void main(String[] args) throws Exception {
          List<Shape> shapes = Suppliers.
                  create(ArrayList::new, Shape::new, 3);
          Apply.apply(shapes,Shape.class.getMethod("rotate"));
          Apply.apply(shapes,Shape.class.getMethod("resize", int.class),7);
          List<Square> squares =
                  Suppliers.create(ArrayList::new, Square::new, 3);
          Apply.apply(squares, Shape.class.getMethod("rotate"));
          Apply.apply(squares, Shape.class.getMethod("resize", int.class), 7);
  
          Apply.apply(new FilledList<>(Shape::new, 3),
                  Shape.class.getMethod("rotate"));
          Apply.apply(new FilledList<>(Square::new, 3),
                  Shape.class.getMethod("rotate"));
      }
  }
  ```

  如上可以看到，`ApplyTest`中的`apply`方法可以接受任何实现了`Iterable`接口的类。不过反射的实现速度比较慢。下面展示使用Java 8 的函数式方法改进：

  ```java
  public class ApplyFunctional {
      public static void main(String[] args) {
          Stream.of(Stream.generate(Shape::new).limit(2),
                  Stream.generate(Square::new).limit(2))
                  .flatMap(c -> c)// flatten into on stream
                  .peek(Shape::rotate) //  `peek()` 执行一个操作（此处是出于副作用），并在未更改																		的情况下传递对象
                  .forEach(s -> ((Shape) s).resize(7));
          new FilledList<>(Shape::new, 2)
                  .forEach(Shape::rotate);
          new FilledList<>(Square::new, 2)
                  .forEach(Shape::rotate);
      }
  }
  ```

- **Java 8**的辅助潜在类型

  重写`DogsAndRobots`:

  ```java
  public class DogsAndRobotMethodReferences {
      public static void main(String[] args) {
          CommunicateNew.perform(new PerformingDogNew(), PerformingDogNew::speak,
                  PerformingDogNew::sit);
          CommunicateNew.perform(new Mime(), Mime::walkAgainstTheWind,
                  Mime::pushInvisibleWalls);
      }
  }
  
  class PerformingDogNew extends Dog {
      public void speak() {
          System.out.println("Woof!");
      }
      public void sit() {
          System.out.println("Sitting");
      }
      public void reproduce() {
      }
  }
  
  class RobotNew {
      public void speak() {
          System.out.println("Click!");
      }
      public void sit() {
          System.out.println("Clank!");
      }
      public void oilChange() {
      }
  }
  class CommunicateNew {
      public static <P> void perform(P performer,
                                     Consumer<P> actionOne,
                                     Consumer<P> actionTwo) {
          actionOne.accept(performer);
          actionTwo.accept(performer);
      }
  }
  
  ```

- 使用**Suppliers**类的通用方法

  ```java
  public class Suppliers {
      // Create a collection and fill it:
      public static <T, C extends Collection<T>> C
      create(Supplier<C> factory, Supplier<T> gen, int n) {
          return Stream.generate(gen)
                  .limit(n)
                  .collect(factory, C::add, C::addAll);
      }
  
      // Fill an existing collection:
      public static <T, C extends Collection<T>>
      C fill(C coll, Supplier<T> gen, int n) {
          Stream.generate(gen)
                  .limit(n)
                  .forEach(coll::add);
          return coll;
      }
      // Use an unbound method reference to
      // produce a more general method:
      public static <H, A> H fill(H holder,
                                  BiConsumer<H, A> adder, Supplier<A> gen, int n) {
          Stream.generate(gen)
                  .limit(n)
                  .forEach(a -> adder.accept(holder, a));
          return holder;
      }
  
  }
  ```

  测试

  ```java
  public class BankTeller {
      public static void serve(Teller t, Customer c) {
          System.out.println(t + " serves " + c);
      }
  
      public static void main(String[] args) {
          // Demonstrate create():
          RandomList<Teller> tellers =
                  Suppliers.create(
                          RandomList::new, Teller::new, 4);
          // Demonstrate fill():
          List<Customer> customers = Suppliers.fill(
                  new ArrayList<>(), Customer::new, 12);
          customers.forEach(c ->
                  serve(tellers.select(), c));
          // Demonstrate assisted latent typing:
          Bank bank = Suppliers.fill(
                  new Bank(), Bank::put, BankTeller::new, 3);
          // Can also use second version of fill():
          List<Customer> customers2 = Suppliers.fill(
                  new ArrayList<>(),
                  List::add, Customer::new, 12);
      }
  }
  class Customer {
      private static long counter = 1;
      private final long id = counter++;
      @Override
      public String toString() {
          return "Customer" + id;
      }
  }
  class Teller {
      private static long counter = 1;
      private final long id = counter++;
      @Override
      public String toString() {
          return "Teller " + id;
      }
  }
  class Bank {
      private List<BankTeller> tellers =
              new ArrayList<>();
      public void put(BankTeller bt) {
          tellers.add(bt);
      }
  }
  ```

## 总结

- 即便“狗在猫列表中”这个论据经常被用来证明泛型是必要的，但是它仍旧是有问题的。就像我在本章开头声称的，我不相信这就是泛型这个概念真正的含义。相反，泛型正如其名称所暗示的：它是一种方法，通过它可以编写出更“泛化”的代码，这些代码对于它们能够作用的类型具有更少的限制，因此单个的代码段可以应用到更多的类型上

#  枚举

## 基本 enum 特性

- 创建 `enum `时，编译器会为你生成一个相关的类，这个类继承自 `Java.lang.Enum`。

  ```java
  public class EnumClass {
      public static void main(String[] args) {
          for (Shrubbery each : Shrubbery.values()) {
              System.out.println(each + " ordinal: "  +each.ordinal());
              System.out.print(each.compareTo(Shrubbery.CRAWLING) + " ");
              System.out.print(each.equals(Shrubbery.CRAWLING) + " ");
              System.out.println(each == Shrubbery.CRAWLING);
              System.out.println(each.getDeclaringClass());
              System.out.println(each.name());
              System.out.println("********************");
          }
          // Produce an enum value from a String name:
          for (String s : "HANGING CRAWLING GROUND".split(" ")) {
              Shrubbery shrubbery = Enum.valueOf(Shrubbery.class, s);
              System.out.println(shrubbery);
          }
      }
  }
  public enum Shrubbery {
      GROUND, CRAWLING, HANGING
  }
  /**output
  
   * GROUND ordinal: 0
   * -1 false false
   * class com.chapter22.basicfeatures.Shrubbery
   * GROUND
   * ********************
   * CRAWLING ordinal: 1
   * 0 true true
   * class com.chapter22.basicfeatures.Shrubbery
   * CRAWLING
   * ********************
   * HANGING ordinal: 2
   * 1 false false
   * class com.chapter22.basicfeatures.Shrubbery
   * HANGING
   * ********************
   * HANGING
   * CRAWLING
   * GROUND
   */
  ```

  `ordinal() `返回每个 **enum**实例声明的次序，从 0 开始的`int`值。可以使用==来比较 **enum**实例，编译器会自动为你提供 `equals()` 和` hashCode() `方法。`valueOf() `是在 **Enum**中定义的 `static `方法，它根据给定的名字返回相应的**enum**实例，如果不存在给定名字的实例，将会抛出异常。

- 静态导入

  ```java
  import static com.chapter22.basicfeatures.SpicinessEnum.*;
  public class Burrito {
      private SpicinessEnum degree;
      public Burrito(SpicinessEnum degree) {
          this.degree = degree;
      }
      @Override
      public String toString() {
          return "Burrito is "+ degree;
      }
  
      public static void main(String[] args) {
          System.out.println(new Burrito(NOT));
          System.out.println(new Burrito(MEDIUM));
          System.out.println(new Burrito(HOT));
      }
  }
  public enum SpicinessEnum {
      NOT, MILD, MEDIUM, HOT, FLAMING
  }
  ```

## 向enum中添加方法

- 我们可以向 **enum** 中添加方法。**enum** 甚至可以有 main() 方法。

  ```java
  public enum OzWitch {
      WEST("Miss Gulch, aka the Wicked Witch of the West"),
      NORTH("Glinda, the Good Witch of the North"),
      EAST("Wicked Witch of the East, wearer of the Ruby Slippers, " +
              "crushed by Dorothy's house"),
      SOUTH("Good by inference, but missing");
      private String description;
      OzWitch(String description) {
          this.description = description;
      }
      public String getDescription() {
          return description;
      }
      public static void main(String[] args) {
          for (OzWitch witch : OzWitch.values()) {
              System.out.println(
                      witch + ": " + witch.getDescription());
          }
      }
  }
  ```

  **Java** 要求你必须先定义 **enum** 实例。如果在定义 **enum** 实例之前定义了任何方法或属性，那么在编译时就会得到错误信息。

  `enum`构造器默认的修改符是`private`。器构造器应该声明为`private`，因为只能在 `enum `定义的内部使用其构造器创建 `enum `实例。一旦 `enum `的定义结束，编译器就不允许我们再使用其构造器来创建任何实例了。

- 重写方法

  ```java
  public enum  SpaceShip {
      SCOUT, CARGO, TRANSPORT,
      CRUISER, BATTLESHIP, MOTHERSHIP;
      @Override
      public String toString() {
          String id = name();
          String lower = id.substring(1).toLowerCase();
          return id.charAt(0) + lower;
      }
      public static void main(String[] args) {
          Stream.of(values()).forEach(each -> System.out.print(each + " "));
      }
  }
  /** output
   * Scout Cargo Transport Cruiser Battleship Mothership
   */
  ```



## switch 语句中的 enum

- 使用 **enum**构造一个小型状态机

  ```java
  public class TrafficLight {
      private Signal color = Signal.RED;
      private void change() {
          switch (color) {
              // Note you don't have to say Signal.RED in the case statement:
              case RED: color = Signal.GREEN;
                  break;
              case GREEN: color = Signal.YELLOW;
                  break;
              case YELLOW: color = Signal.RED;
                  break;
          }
      }
      @Override
      public String toString() {
          return "The traffic light is " + color;
      }
      public static void main(String[] args) {
          TrafficLight light = new TrafficLight();
          for (int i = 0; i < 7; i++) {
              System.out.println(light);
              light.change();
          }
      }
  }
  public enum  Signal {
      GREEN, YELLOW, RED,
  }
  ```

## values方法神秘之处

- 查看`Enum `类，发现并没有`values()`方法。编写一个反射简单机制查看：

  ```java
  public class Reflection {
      public static Set<String> analyze(Class<?> enumClass) {
          System.out.println(
                  "_____ Analyzing " + enumClass + " _____");
          System.out.println("Interface: ");
          for (Type t : enumClass.getGenericInterfaces()) {
              System.out.println(t);
          }
          System.out.println("Base:" + enumClass.getSuperclass());
          System.out.println("Method: ");
          Set<String> methods = new TreeSet<>();
          for (Method m : enumClass.getMethods()) {
              methods.add(m.getName());
          }
          System.out.println(methods);
          return methods;
      }
  
      public static void main(String[] args) throws IOException {
          Set<String> exploreMethods = analyze(Explore.class);
          Set<String> enumMethods = analyze(Enum.class);
          System.out.println(
                  "Explore.containsAll(Enum)? " +
                          exploreMethods.containsAll(enumMethods));
  
          System.out.print("Explore.removeAll(Enum): ");
          exploreMethods.removeAll(enumMethods);
          System.out.println(exploreMethods);
      }
  }
  /**
   * _____ Analyzing class com.chapter22.values.Explore _____
   * Interface: 
   * Base:class java.lang.Enum
   * Method: 
   * [compareTo, equals, getClass, getDeclaringClass, hashCode, name, notify, notifyAll, ordinal, toString, valueOf, values, wait]
   * _____ Analyzing class java.lang.Enum _____
   * Interface: 
   * java.lang.Comparable<E>
   * interface java.io.Serializable
   * Base:class java.lang.Object
   * Method: 
   * [compareTo, equals, getClass, getDeclaringClass, hashCode, name, notify, notifyAll, ordinal, toString, valueOf, wait]
   * Explore.containsAll(Enum)? true
   * Explore.removeAll(Enum): [values]
   */
  ```

  通过`javap -c Explore`命令查看：

  <img src="./pic/values.png">

  从反编译结果看出，`values()`方法是由编译器添加的`static`方法。同时编译器还添加了`valueof(String)`方法(跟`Enum`父类中的`valueof`方法的参数个数不同，截图中没有展示)。同时编译器将`Explore`编译成了`final`类，所以不能够扩展一个枚举类型的类。
  
  由于 `values() `是由编译器插入到 `enum `定义中的` static `方法，如果你将 `enum `实例向上转型为 `Enum`，那么 `values() `就不可访问了。不过，在 `Class` 中可以通过 `getEnumConstant `方法，取得所有 enum 实例。
  
  ```java
  public class UpcastEnum {
      public static void main(String[] args) {
          Search[] values = Search.values();
          Enum e = Search.HITHER; // upcast
          Enum[] enums = e.getClass().getEnumConstants();
          for (Enum en : enums) {
              System.out.println(en);
          }
      }
  }
  enum Search { HITHER, YON }
  ```
  
- 所有的 `enum` 都继承自 `Java.lang.Enum `类。由于 Java 不支持多重继承，所以你的 enum 不能再继承其他类。但可以实现接口。

  ```java
  public class EnumImplementation {
      public static <T> void printNext(Supplier<T> rg){
          System.out.print(rg.get() +",");
      }
      public static void main(String[] args) {
          CartoonCharacter cc =  CartoonCharacter.BOB;
          for (int i = 0; i < 10; i++) {
              printNext(cc);
          }
      }
  }
  enum CartoonCharacter implements Supplier<CartoonCharacter> {
      SLAPPY, SPANKY, PUNCHY,
      SILLY, BOUNCY, NUTTY, BOB;
      private Random rand = new Random(47);
      @Override
      public CartoonCharacter get() {
          return values()[rand.nextInt(values().length)];
      }
  }
  ```

## 随机选择工具

- 利用泛型，创建一个随机选择工具(不需要像上例那样调用`printNext`方法是要先有一个`enum`实例)

  ```java
  public class EnumImplementation {
      public static <T> void printNext(Supplier<T> rg){
          System.out.print(rg.get() +",");
      }
      public static void main(String[] args) {
          CartoonCharacter cc =  CartoonCharacter.BOB;
          for (int i = 0; i < 10; i++) {
              printNext(cc);
          }
      }
  }
  enum CartoonCharacter implements Supplier<CartoonCharacter> {
      SLAPPY, SPANKY, PUNCHY,
      SILLY, BOUNCY, NUTTY, BOB;
      private Random rand = new Random(47);
      @Override
      public CartoonCharacter get() {
          return values()[rand.nextInt(values().length)];
      }
  }
  public class RandomTest {
      public static void main(String[] args) {
          for (int i = 0; i < 20; i++) {
              System.out.println(
                      Enums.random(Activity.class) + ""
              );
          }
      }
  }
  enum Activity { SITTING, LYING, STANDING, HOPPING,
      RUNNING, DODGING, JUMPING, FALLING, FLYING }
  ```

## 使用接口组织枚举

- 有时候想扩展枚举中的元素，但其又不能继承。可以在一个接口的内部，创建实现该接口的枚举，以此将元素进行分组，可以达到将枚举元素分类组织的目的

  ```java
  public interface Food {
      enum Appetizer implements Food {
          SALAD, SOUP, SPRING_ROLLS;
      }
      enum MainCourse implements Food {
          LASAGNE, BURRITO, PAD_THAI,
          LENTILS, HUMMOUS, VINDALOO;
      }
      enum Dessert implements Food {
          TIRAMISU, GELATO, BLACK_FOREST_CAKE,
          FRUIT, CREME_CARAMEL;
      }
      enum Coffee implements Food {
          BLACK_COFFEE, DECAF_COFFEE, ESPRESSO,
          LATTE, CAPPUCCINO, TEA, HERB_TEA;
      }
  }
  ```

- 创建“枚举中的枚举”

  ```java
  public enum  Course {
      APPETIZER(Food.Appetizer.class),
      MAINCOURSE(Food.MainCourse.class),
      DESSERT(Food.Dessert.class),
      COFFEE(Food.Coffee.class);
      private Food[] values;
      private Course(Class<? extends Food> kind) {
          values = kind.getEnumConstants();
      }
      public Food randomSelection() {
          return Enums.random(values);
      }
  }
  public class Meal {
      public static void main(String[] args) {
          for (int i = 0; i < 5; i++) {
              for (Course course : Course.values()) {
                  Food food = course.randomSelection();
                  System.out.println(food);
              }
              System.out.println("***");
          }
      }
  }
  ```


## 使用 EnumSet 替代 Flags

- **Java 5**引入**EnumSet**是为了替代传统基于`int`的“位标志”，这种标志可以用来表示某种“开/关”信息。

- **EnumSet** 非常快速高效。它在说明一个二进制位是否存在时，具有更好的表达能力，并且无需担心性能

  ```java
  import static com.chapter22.enumsets.AlarmPoints.*;
  public class EnumSets {
      public static void main(String[] args) {
          EnumSet<AlarmPoints> points = EnumSet.noneOf(AlarmPoints.class);
          points.add(BATHROOM);
          System.out.println(points);
          points.addAll(EnumSet.of(STAIR1,STAIR2,KITCHEN));
          System.out.println(points);
          points = EnumSet.allOf(AlarmPoints.class);
          System.out.println(points);
          points.removeAll(
                  EnumSet.of(STAIR1,STAIR2,KITCHEN)
          );
          System.out.println(points);
          points.removeAll(EnumSet.range(OFFICE1,OFFICE4));
          System.out.println(points);
          points = EnumSet.complementOf(points);
          System.out.println(points);
      }
  }
  public enum AlarmPoints {
      STAIR1, STAIR2, LOBBY, OFFICE1, OFFICE2, OFFICE3,
      OFFICE4, BATHROOM, UTILITY, KITCHEN
  }
  ```

- `EnumSet`对`of`方法进行了多次重载。从侧面表现了 EnumSet 对性能的关注(可变参数性能稍微差些)。

- `EnumSet `的基础是 `long`，一个 `long `值有 64 位，而一个 `enum `实例只需一位 `bit `表示其是否存在。测试超过64位的情况：

  ```java
  public class BigEnumSet {
      enum Big { A0, A1, A2, A3, A4, A5, A6, A7, A8, A9,
          A10, A11, A12, A13, A14, A15, A16, A17, A18, A19,
          A20, A21, A22, A23, A24, A25, A26, A27, A28, A29,
          A30, A31, A32, A33, A34, A35, A36, A37, A38, A39,
          A40, A41, A42, A43, A44, A45, A46, A47, A48, A49,
          A50, A51, A52, A53, A54, A55, A56, A57, A58, A59,
          A60, A61, A62, A63, A64, A65, A66, A67, A68, A69,
          A70, A71, A72, A73, A74, A75 }
  
      public static void main(String[] args) {
          EnumSet<Big> bigEnumSet = EnumSet.allOf(Big.class);
          System.out.println(bigEnumSet);
      }
  }
  /**	output
       * [A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12,
       * A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23,
       * A24, A25, A26, A27, A28, A29, A30, A31, A32, A33, A34,
       * A35, A36, A37, A38, A39, A40, A41, A42, A43, A44, A45,
       * A46, A47, A48, A49, A50, A51, A52, A53, A54, A55, A56,
       * A57, A58, A59, A60, A61, A62, A63, A64, A65, A66, A67,
       * A68, A69, A70, A71, A72, A73, A74, A75]
       */
  ```

## 使用 EnumMap

- ***EnumMap*** 是一种特殊的 ***Map***，它要求其中的键(***key***）必须来自一个 enum;内部使用数组实现。

  演示**命令模式**：

  ```java
  public interface Command {
      void action();
  }
  public enum AlarmPoints {
      STAIR1, STAIR2, LOBBY, OFFICE1, OFFICE2, OFFICE3,
      OFFICE4, BATHROOM, UTILITY, KITCHEN
  }
  import static com.chapter22.enumsets.AlarmPoints.*;
  public class EnumMaps {
      public static void main(String[] args) {
          EnumMap<AlarmPoints, Command> em =
                  new EnumMap<>(AlarmPoints.class);
          em.put(KITCHEN,()-> System.out.println("Kitchen fire!"));
          em.put(BATHROOM,()-> System.out.println("Bathroom alert!"));
          for (Map.Entry<AlarmPoints, Command> e : em.entrySet()) {
              System.out.print(e.getKey()+ ": ");
              e.getValue().action();
          }
          try {
              em.get(UTILITY).action();
          } catch (Exception e) {
              System.out.println("Expected: " + e);
          }
      }
  }
  	/**output:
       * 
       * BATHROOM: Bathroom alert!
       * KITCHEN: Kitchen fire!
       * Expected: java.lang.NullPointerException
       */
  ```

- 与常量相关的方法相比，***EnumMap***有一个优点，那***EnumMap***允许程序员改变值对象，而常量相关的方法在编译期就被固定了。稍后你会看到，在你有多种类型的 ***enum***，而且它们之间存在互操作的情况下，我们可以用 ***EnumMap*** 实现多路分发（*multiple dispatching*）。

## 常量特定方法

- ***Java***允许为***enum***实例编写方法来赋予各自不同的行为。为 ***enum*** 定义一个或多个 ***abstract***方法，然后为每个 ***enum*** 实例实现该抽象方法：

  ```java
  public enum ConstantSpecificMethod {
      DATE_TIME {
          @Override
          String getInfo() {
              return DateFormat.getDateInstance()
                      .format(new Date());
          }
      },
      CLASSPATH {
          @Override
          String getInfo() {
              return System.getenv("CLASSPATH");
          }
      },
      VERSION {
          @Override
          String getInfo() {
              return System.getProperty("java.version");
          }
      };
      abstract String getInfo();
  
      public static void main(String[] args) {
          for (ConstantSpecificMethod csm : values()) {
              System.out.println(csm.getInfo());
          }
      }
  }
  ```

  这通常也称为表驱动的代码（table-driven code，请注意它与前面提到的命令模式的相似之处）。

- 每个 ***enum***实例可以具备自己独特的行为，这似乎说明每个 ***enum***实例就像一个独特的类。在上面的例子中，***enum*** 实例似乎被当作其“超类”`ConstantSpecificMethod `来使用，在调用 `getInfo()` 方法时，体现出多态的行为。但我们并不能真的将***enum***实例作为一个***Class***来使用

- 场景：关于洗车的例子。每个顾客在洗车时，都有一个选择菜单，每个选择对应一个不同的动作。可以将一个常量相关的方法关联到一个选择上，再使用一个 ***EnumSet***来保存客户的选择

  ```java
  public class CarWash {
      EnumSet<Cycle> cycles = EnumSet.of(Cycle.BASIC,Cycle.RINSE);
    public void add(Cycle cycle){
          cycles.add(cycle);
    }
      public void washCar(){
          for (Cycle cycle : cycles) {
              cycle.action();
          }
      }
      @Override
      public String toString() {
          return cycles.toString();
      }
      public static void main(String[] args) {
          CarWash wash = new CarWash();
          System.out.println(wash);
          wash.washCar();
          wash.add(Cycle.BLOWDRY);
          wash.add(Cycle.BLOWDRY); // Duplicates ignored
          wash.add(Cycle.RINSE);
          wash.add(Cycle.HOTWAX);
          System.out.println(wash);
          wash.washCar();
      }
  
      public enum Cycle {
          UNDERBODY {
              @Override void action() {
                  System.out.println("Spraying the underbody");
              }
          },
          WHEELWASH {
              @Override
              void action() {
                  System.out.println("Washing the wheels");
              }
          },
          PREWASH {
              @Override void action() {
                  System.out.println("Loosening the dirt");
              }
          },
          BASIC {
              @Override
              void action() {
                  System.out.println("The basic wash");
              }
          },
          HOTWAX {
              @Override void action() {
                  System.out.println("Applying hot wax");
              }
          },
          RINSE {
              @Override void action() {
                  System.out.println("Rinsing");
              }
          },
          BLOWDRY {
              @Override void action() {
                  System.out.println("Blowing dry");
              }
          };
          abstract void action();
      }
  }
  ```
  
  与使用匿名内部类相比较，定义常量相关方法的语法更高效、简洁。
  
  枚举还可以覆盖常量相关方法：
  
  ```java
  public enum OverrideConstantSpecific {
      NUT, BOLT,
      WASHER {
          @Override
          void needOverride() {
              System.out.println("Overridden method");
          }
      };
      void needOverride() {
          System.out.println("default behavior");
      }
      public static void main(String[] args) {
          for (OverrideConstantSpecific specific : values()) {
              System.out.println(specific + ": ");
              specific.needOverride();
          }
      }
  }
  	/** output
       * NUT: 
       * default behavior
       * BOLT: 
       * default behavior
       * WASHER: 
       * Overridden method
       */
  ```

## enum 在责任链中的应用

- 场景描述：以一个邮局的模型为例。邮局需要以尽可能通用的方式来处理每一封邮件，并且要不断尝试处理邮件，直到该邮件最终被确定为一封死信。其中的每一次尝试可以看作为一个策略（也是一个设计模式），而完整的处理方式列表就是一个职责链

  ```java
  public class Mail {
      public GeneralDelivery generalDelivery;
      public Scannability scannability;
      public Readability readability;
      public Address address;
      public ReturnAddress returnAddress;
      public static long counter = 0;
      public long id = counter++;
  
      @Override
      public String toString() {
          return "Mail " + id;
      }
  
      public String detail() {
          return toString() + ", General Delivery: " + generalDelivery +
                  ", Address Scanability: " + scannability +
                  ", Address Readability: " + readability +
                  ", Address Address: " + address +
                  ", Return address: " + returnAddress;
      }
  
      public static Mail randomMail() {
          Mail m = new Mail();
          m.generalDelivery = Enums.random(GeneralDelivery.class);
          m.scannability = Enums.random(Scannability.class);
          m.readability = Enums.random(Readability.class);
          m.address = Enums.random(Address.class);
          m.returnAddress = Enums.random(ReturnAddress.class);
          return m;
      }
  
      public static Iterable<Mail> generator(final int count) {
          return new Iterable<Mail>() {
              int n = count;
              @Override
              public Iterator<Mail> iterator() {
                  return new Iterator<Mail>() {
                      @Override
                      public boolean hasNext() {
                          return n-- > 0;
                      }
                      @Override
                      public Mail next() {
                          return randomMail();
                      }
                  };
              }
          };
      }
  
      enum GeneralDelivery {YES, NO1, NO2, NO3, NO4, NO5}
  
      enum Scannability {UNSCANNABLE, YES1, YES2, YES3, YES4}
  
      enum Readability {ILLEGIBLE, YES1, YES2, YES3, YES4}
  
      enum Address {INCORRECT, OK1, OK2, OK3, OK4, OK5, OK6}
  
      enum ReturnAddress {MISSING, OK1, OK2, OK3, OK4, OK5}
  
  }
  import static com.chapter22.responsibilitymodel.Mail.*;
  
  public class PostOffice {
      enum MailHandler {
          GENERAL_DELIVERY {
              @Override
              boolean handle(Mail m) {
                  if (m.generalDelivery == GeneralDelivery.YES) {
                      System.out.println(
                              "Using general delivery for " + m);
                      return true;
                  }
                  return false;
              }
          },
          MACHINE_SCAN {
              @Override
              boolean handle(Mail m) {
                  switch (m.scannability) {
                      case UNSCANNABLE:
                          return false;
                      default:
                          switch (m.address) {
                              case INCORRECT:
                                  return false;
                              default:
                                  System.out.println(
                                          "Delivering " + m + " automatically");
                                  return true;
                          }
                  }
              }
          },
          VISUAL_INSPECTION {
              @Override
              boolean handle(Mail m) {
                  switch (m.readability) {
                      case ILLEGIBLE:
                          return false;
                      default:
                          switch (m.address) {
                              case INCORRECT:
                                  return false;
                              default:
                                  System.out.println(
                                          "Delivering " + m + " normally");
                                  return true;
                          }
                  }
              }
          },
          RETURN_TO_SENDER {
              @Override
              boolean handle(Mail m) {
                  switch (m.returnAddress) {
                      case MISSING:
                          return false;
                      default:
                          System.out.println(
                                  "Returning " + m + " to sender");
                          return true;
                  }
              }
          };
  
          abstract boolean handle(Mail m);
      }
  
      static void handle(Mail m){
          for (MailHandler handler : MailHandler.values()) {
             if(handler.handle(m)){
                return;
             }
          }
          System.out.println(m +" is  a dead letter");
      }
  
      public static void main(String[] args) {
          for (Mail mail : generator(10)) {
              System.out.println(mail.detail());
              handle(mail);
              System.out.println("***********");
          }
      }
  }
  ```

## enum的状态机模型

- 自动售贷机是一个很好的状态机的例子

  ```java
  public enum  Input {
      NICKEL(5), DIME(10), QUARTER(25), DOLLAR(100),
    TOOTHPASTE(200), CHIPS(75), SODA(100), SOAP(50),
      ABORT_TRANSACTION{
          @Override
          int amount() {
              throw new RuntimeException("ABORT.amount()");
          }
      },
      STOP{
          @Override
          int amount() {
              throw new RuntimeException("SHUT_DOWN.amount()");
          }
      };
      int value; // In cents
      Input(int value) { this.value = value; }
      Input() {}
      int amount() { return value; }; // In cents
      static Random rand = new Random(47);
      public static Input randomSelection(){
          return values()[rand.nextInt(values().length -1)]; // don't include stop
      }
  }
  ```
  
  `Input`代表向售货机中添加钱，选择产品类型，和选择放弃交易和关闭机器的操作。
  
  ```java
  public enum Category {
      MONEY(Input.NICKEL, Input.DIME,
              Input.QUARTER, Input.DOLLAR),
      ITEM_SELECTION(Input.TOOTHPASTE, Input.CHIPS,
              Input.SODA, Input.SOAP),
      QUIT_TRANSACTION(Input.ABORT_TRANSACTION),
      SHUT_DOWN(Input.STOP);
      private Input[] values;
      Category(Input... values) {
          this.values = values;
      }
      private static EnumMap<Input,Category> categories = new EnumMap<>(Input.class);
      static {
          for (Category c : Category.class.getEnumConstants()) {
              for (Input type : c.values) {
                  categories.put(type,c);
              }
          }
      }
      public static Category categories(Input input){
          return categories.get(input);
      }
  }
  ```
  
  `Category`对`Input`进行了种类划分，包括：钱、商品选择、停止交易和关闭。并将每个`Input`对应的`Category`放进`EnumMap`中。
  
  ```java
  public class VendingMachine {
      private static State state = State.RESTING;
      private static int amount = 0;
      private static Input selection = null;
      enum StateDuration {TRANSIENT} // Tagging enum
      enum State {
          RESTING {
              @Override
              void next(Input input) {
                  switch (Category.categories(input)) {
                      case MONEY:
                          amount += input.amount();
                          state = ADDING_MONEY;
                          break;
                      case SHUT_DOWN:
                          state = TERMINAL;
                      default:
                  }
              }
          }, ADDING_MONEY {
              @Override
              void next(Input input) {
                  switch (Category.categories(input)) {
                      case MONEY:
                          amount += input.amount();
                          break;
                      case ITEM_SELECTION:
                          selection = input;
                          if (amount < selection.amount()) {
                              System.out.println(
                                      "Insufficient money for " + selection);
                          } else {
                              state = DISPENSING;
                          }
                          break;
                      case QUIT_TRANSACTION:
                          state = GIVING_CHANGE;
                          break;
                      case SHUT_DOWN:
                          state = TERMINAL;
                      default:
                  }
              }
          }, DISPENSING(StateDuration.TRANSIENT) {
              @Override
              void next() {
                  System.out.println("here is your " + selection);
                  amount -= selection.amount();
                  state = GIVING_CHANGE;
              }
          }, GIVING_CHANGE(StateDuration.TRANSIENT) {
              @Override
              void next() {
                  if (amount > 0) {
                      System.out.println("Your change: " + amount);
                      amount = 0;
                  }
                  state = RESTING;
              }
          }, TERMINAL {
              @Override
              void next() {
                  System.out.println("Halted");
              }
          };
          private boolean isTransient = false;
          State() {
          }
          State(StateDuration trans) {
              isTransient = true;
          }
          void next(Input input) {
              throw new RuntimeException("Only call " +
                      "next(Input input) for non-transient states");
          }
          void next() {
              throw new RuntimeException(
                      "Only call next() for " +
                              "StateDuration.TRANSIENT states");
          }
          void output() {
              System.out.println(amount);
          }
      }
      static void run(Supplier<Input> gen){
          while(state != State.TERMINAL) {
              state.next(gen.get());
              while(state.isTransient)
                  state.next();
              state.output();
          }
      }
  
      public static void main(String[] args) {
          Supplier<Input> gen = new RandomInputSupplier();
          run(gen);
      }
  }
  // For a basic sanity check:
  class RandomInputSupplier implements Supplier<Input>{
      @Override
      public Input get() {
          return Input.randomSelection();
      }
  }
  
  class FileInputSupplier implements Supplier<Input> {
      private Iterator<String> input;
  
      public FileInputSupplier(String fileName) {
          try {
              input = Files.lines(Paths.get(fileName)).skip(1)
                      .flatMap(s -> Arrays.stream(s.split(";")))
                      .map(String::trim).collect(Collectors.toList()).iterator();
          } catch (IOException e) {
              throw new RuntimeException(e);
          }
      }
  
      @Override
      public Input get() {
          if (!input.hasNext()) {
              return null;
          }
          return Enum.valueOf(Input.class, input.next().trim());
      }
  }
  
  ```
  
  文件：
  
  ```tex
  QUARTER; QUARTER; QUARTER; CHIPS;
  DOLLAR; DOLLAR; TOOTHPASTE;
  QUARTER; DIME; ABORT_TRANSACTION;
  QUARTER; DIME; SODA;
  QUARTER; DIME; NICKEL; SODA;
  ```
  
  这种设计有一个缺陷，它要求 ` VendingMachine `中的属性`enum State `必须声明为 `static`，这意味着，你只能有一个 `VendingMachine `实例。

## 多重调度

- 单一调度：如果要用**两种不确定类型**的对象来处理运算，如`a.plus(b)`，***java***用动态绑定机制只能确定一种类型。无法处理我们所描述的状况。

- 使用两路分发，那么就必须有两个方法调用：第一个方法调用决定第一个未知类型，第二个方法调用决定第二个未知的类型

  ```java
  import static com.chapter22.dispatch.Outcome.*;
  public interface Item {
      Outcome compete(Item it);
      Outcome eval(Paper p);
      Outcome eval(Scissors s);
      Outcome eval(Rock r);
  }
  class Paper implements Item{
      @Override
      public Outcome compete(Item it) {
          return it.eval(this);
      }
      @Override
      public Outcome eval(Paper p) {
          return DRAW;
      }
      @Override
      public Outcome eval(Scissors s) {
          return WIN;
      }
      @Override
      public Outcome eval(Rock r) {
          return LOSE;
      }
      @Override
      public String toString() { return "Paper"; }
  }
  class Scissors implements Item{
      @Override
      public Outcome compete(Item it) {
          return it.eval(this);
      }
      @Override
      public Outcome eval(Paper p) {
          return LOSE;
      }
      @Override
      public Outcome eval(Scissors s) {
          return DRAW;
      }
      @Override
      public Outcome eval(Rock r) {
          return WIN;
      }
      @Override
      public String toString() { return "Scissors"; }
  }
  class Rock implements Item{
      @Override
      public Outcome compete(Item it) {
          return it.eval(this);
      }
      @Override
      public Outcome eval(Paper p) {
          return WIN;
      }
      @Override
      public Outcome eval(Scissors s) {
          return LOSE;
      }
      @Override
      public Outcome eval(Rock r) {
          return DRAW;
      }
      @Override
      public String toString() { return "Rock"; }
  }
  public enum Outcome {
      WIN,LOSE,DRAW
  }
  public class RoShamBo1 {
      static final int SIZE = 20;
      private static Random rand = new Random(47);
  
      public static Item newItem() {
          switch (rand.nextInt(3)) {
              default:
              case 0:
                  return new Scissors();
              case 1:
                  return new Paper();
              case 2:
                  return new Rock();
          }
      }
  
      public static void match(Item a, Item b) {
          System.out.println(a + " vs. " + b + ": " + a.compete(b));
      }
  
      public static void main(String[] args) {
          for (int i = 0; i < SIZE; i++) {
              match(newItem(), newItem());
          }
      }
  }
  ```

  `Item`是多路分发的类型。`RoShamBo1`的`match`方法通过调用`Item`的`compete`来进行分发。在`a.compete(b)`中，`a`的类型在调用`compete`方法的运行时确定类型，在`compete`方法内部通过调用`eval`方法进行第二次分发。

## 使用enum 进行分发

- 使用构造器来初始化每个 enum 实例，并以“一组”结果作为参数。这二者放在一块，形成了类似查询表的结构：

  ```java
  public interface Competitor<T extends Competitor<T>> {
      Outcome compete(T competitor);
  }
  public class RoShamBo {
      public static <T extends Competitor<T>> void match(T a,T b){
          System.out.println(
                  a + " vs. " + b + ": " +  a.compete(b));
  
      }
      public static <T extends Enum<T> & Competitor<T>> void play(Class<T>rsbClass,int size){
          for (int i = 0; i < size; i++) {
              match(Enums.random(rsbClass),Enums.random(rsbClass));
          }
      }
  }
  import static com.chapter22.dispatch.Outcome.*;
  public enum  RoShamBo2 implements Competitor<RoShamBo2>{
      PAPER(DRAW,LOSE,WIN),
      SCISSOR(WIN,DRAW,LOSE),
      ROCK(LOSE,WIN,DRAW);
      private Outcome vPAPER, vSCISSORS, vROCK;
      RoShamBo2(Outcome paper, Outcome scissors, Outcome rock) {
          this.vPAPER = paper;
          this.vSCISSORS = scissors;
          this.vROCK = rock;
      }
      @Override
      public Outcome compete(RoShamBo2 it) {
          switch (it){
              default:
              case PAPER:return vPAPER;
              case SCISSOR:return vSCISSORS;
              case ROCK:return vROCK;
          }
      }
      public static void main(String[] args) {
          RoShamBo.play(RoShamBo2.class, 10);
      }
  }
  ```

  这里仍然是使用两路分发来判定两个对象的类型。在` RoShamBol.java`中，两次分发都是通过实际的方法调用实现，而在这个例子中，只有第一次分发是实际的方法调用。第二个分发使用的是`switch`，不过这样做是安全的，因为 `enum`限制了 `switch `语句的选择分支。

## 使用常量相关方法分发

- 常量相关的方法允许我们为每个 enum 实例提供方法的不同实现

  ```java
  import static com.chapter22.dispatch.Outcome.*;
  public enum RoShamBo3 implements Competitor<RoShamBo3> {
      PAPER{
          @Override
          public Outcome compete(RoShamBo3 it) {
              switch (it){
                  default:
                  case PAPER:return DRAW;
                  case SCISSORS:return LOSE;
                  case ROCK:return WIN;
              }
          }
      },SCISSORS{
          @Override
          public Outcome compete(RoShamBo3 it) {
              switch (it){
                  default:
                  case PAPER:return WIN;
                  case SCISSORS:return DRAW;
                  case ROCK:return LOSE;
              }
          }
      },
      ROCK{
          @Override
          public Outcome compete(RoShamBo3 it) {
              switch (it){
                  default:
                  case PAPER:return LOSE;
                  case SCISSORS:return WIN;
                  case ROCK:return DRAW;
              }
          }
      };
      @Override
      public abstract Outcome compete(RoShamBo3 competitor);
      public static void main(String[] args) {
          RoShamBo.play(RoShamBo3.class,20);
      }
  }
  ```

  改进：

  ```java
  public enum  RoShamBo4 implements Competitor<RoShamBo4> {
      ROCK {
          @Override
          public Outcome compete(RoShamBo4 opponent) {
              return compete(SCISSORS, opponent);
          }
      },
      SCISSORS {
          @Override
          public Outcome compete(RoShamBo4 opponent) {
              return compete(PAPER, opponent);
          }
      },
      PAPER {
          @Override
          public Outcome compete(RoShamBo4 opponent) {
              return compete(ROCK, opponent);
          }
      };
  
      public  Outcome compete(RoShamBo4 loser, RoShamBo4 opponent){
          return ((opponent == this) ? Outcome.DRAW
                  : ((opponent == loser) ? Outcome.WIN
                  : Outcome.LOSE));
      }
  
      public static void main(String[] args) {
          RoShamBo.play(RoShamBo4.class, 20);
      }
  }
  ```

## 使用EnumMaps分发

- 使用 EnumMap 能够实现“真正的”两路分发

  ```java
  import static com.chapter22.dispatch.Outcome.*;
  public enum RoShamBo5 implements Competitor<RoShamBo5> {
      PAPER, SCISSORS, ROCK;
      static EnumMap<RoShamBo5, EnumMap<RoShamBo5, Outcome>>
              table = new EnumMap<>(RoShamBo5.class);
      static {
          for (RoShamBo5 it : RoShamBo5.values()) {
              table.put(it,new EnumMap<>(RoShamBo5.class));
          }
          initRow(PAPER, DRAW, LOSE, WIN);
          initRow(SCISSORS, WIN, DRAW, LOSE);
          initRow(ROCK, LOSE, WIN, DRAW);
      }
      static void initRow(RoShamBo5 it,
                          Outcome vPAPER, Outcome vSCISSORS, Outcome vROCK){
          EnumMap<RoShamBo5, Outcome> row = RoShamBo5.table.get(it);
          row.put(RoShamBo5.PAPER,vPAPER);
          row.put(RoShamBo5.SCISSORS, vSCISSORS);
          row.put(RoShamBo5.ROCK, vROCK);
      }
      @Override
      public Outcome compete(RoShamBo5 it) {
          return table.get(this).get(it);
      }
  
      public static void main(String[] args) {
          RoShamBo.play(RoShamBo5.class, 20);
      }
  }
  ```

## 使用二维数组实现分发

- 进一步简化实现两路分发的解决方案

  ```java
  import static com.chapter22.dispatch.Outcome.*;
  public enum RoShamBo6 implements Competitor<RoShamBo6> {
      PAPER, SCISSORS, ROCK;
      private static Outcome[][]table={
              {DRAW,LOSE,WIN},// PAPER
              {WIN, DRAW, LOSE},// SCISSORS
              { LOSE, WIN, DRAW} // ROCK
      };
      @Override
      public Outcome compete(RoShamBo6 other) {
          return table[this.ordinal()][other.ordinal()];
      }
  
      public static void main(String[] args) {
          RoShamBo.play(RoShamBo6.class, 20);
      }
  }
  
  ```

## 总结

本章正好说明了一个“小”功能所能带来的价值。有时恰恰因为它，你才能够优雅而干净地解决问题。正如我在本书中一再强调的那样，优雅与清晰很重要，正是它们区别了成功的解决方案与失败的解决方案。而失败的解决方案就是因为其他人无法理解它。



#  注解

- ***java***中常用的注解：
  - **@Override**:当前的方法定义覆盖基类中的方法。
  - **@Deprecated**：使用该注解的元素被调用，编译器发出告警。
  - **@SuppressWarnings  **:关闭不当的编译器告警信息。 
  - **@SafeVarargs**： ***Java 7***中加入用于禁止对具有泛型***varargs***参数的方法或构造函数的调用方发出警告
  - **@FunctionalInterface**： **Java 8** 中加入用于表示类型声明为函数式接口 

## 基本语法

- 通过注解创建了一个工具用于运行这个方法

  ```java
  public class Testable {
      public void execute(){
          System.out.println("Executing....");
      }
      @Test
      void testExecute(){
          execute();
      }
  }
  @Target(ElementType.METHOD)
  @Retention(RetentionPolicy.RUNTIME)
  public @interface Test {
  }
  ```

  `@Target`定义可以将注解应用的范围(如方法或者字段)，参数是`ElementType[] value()`。

  `@Rentation`定义注解声明期限，在***source***中，在***class***中，或者在***runtime***。

- 注解通常包含一些特定值元素。不包含任何元素的注解称为标记注解(*marker annotation*),如上例的`@Test`。

  ```java
  @Target(ElementType.METHOD)
  @Retention(RetentionPolicy.RUNTIME)
  public @interface UseCase {
      int id();
  
      String description() default "no description";
  }
  public class PasswordUtils {
      @UseCase(id = 47,
              description = "Passwords must contain at least on numeric")
      public boolean validatePassword(String passwd) {
          return passwd.matches("\\w*\\d\\w*");
      }
  
      @UseCase(id = 48)
      public String encryptPassword(String passwd) {
          return new StringBuilder(passwd).reverse().toString();
      }
  
      @UseCase(id = 49,
              description = "New passwords can't equal previously used one")
      public boolean checkForNewPassword(List<String> prePwd, String password) {
          return !prePwd.contains(password);
      }
  }
  ```



## 元注解

- 元注解用于注解其他的注解

  | 注解        | 含义                                                         |
  | ----------- | ------------------------------------------------------------ |
  | @Target     | 注解作用范围；**ElementType** 参数包括： **CONSTRUCTOR**：构造器 ；**FIELD**：字段（包括 enum 实例） **LOCAL_VARIABLE**：局部变量；**METHOD**：方法；**PACKAGE**：包；**PARAMETER**：参数声明 **TYPE**：类、接口（包括注解类型）或者 enum 声明 |
  | @Retention  | 生命周期。**SOURCE**：注解将被编译器丢弃 **CLASS**：注解在 class 文件中可用，但是会被 VM 丢弃。 **RUNTIME**： VM 将在运行期也保留注解，因此可以通过反射机制读取注解的信息。 |
  | @Documented | 将此注解保存在 Javadoc 中                                    |
  | @Inherited  | 允许子类继承父类的注解                                       |
  | @Repeatable | 允许一个注解可以被使用一次或者多次（Java 8）                 |

## 注解处理器

- Java 拓展了反射机制的 API 用于创造注解处理器工具。

  ```java
  public class UseCaseTracker {
      public static void trackUseCases(List<Integer> useCase, Class<?> cl) {
          for (Method m : cl.getDeclaredMethods()) {
              UseCase uc = m.getAnnotation(UseCase.class);
              if (uc != null) {
                  System.out.println("Found Use Case " +
                          uc.id() + "\n" + uc.description());
                  useCase.remove(Integer.valueOf(uc.id()));
              }
          }
          useCase.forEach(i -> System.out.println("Missing use case" + i));
      }
  
      public static void main(String[] args) {
          List<Integer> useCases = IntStream.range(47, 51)
                  .boxed()
                  .collect(Collectors.toList());
          trackUseCases(useCases, PasswordUtils.class);
      }
  }
  ```

## 注解元素

- 注解元素可用类型：
  - 所有基本类型(**int**,**float**,**boolean**)
  - **String**
  - **Class**
  - **enums**
  - **Annotations**
  - 以上所有类型的数组

## 默认值限制

- 元素要么有默认值，要么就在使用注解时提供元素的值。

- 任何**非基本类型的元素**， 无论是在源代码声明时还是在注解接口中定义默认值时，都不能使用 **null** 作为其值

- 可以自定义一些特殊的值，比如空字符串或者负数用于表**达某个元素不存在**

  ```java
  public @interface SimulatingNull {
      int id() default -1;
      String description()default "";
  }
  ```

## 生成外部文件

- 假设你想提供一些基本的对象/关系映射功能，能够自动生成数据库表。你可以使用 XML 描述文件来指明类的名字、每个成员以及数据库映射的相关信息。但是，通过使用注解，你可以把所有信息都保存在 **JavaBean** 源文件中。为此你需要一些用于定义数据库表名称、数据库列以及将 SQL 类型映射到属性的注解。

- 定义一个注解，告诉注解处理器创建一张数据库表

  ```java
  @Target(ElementType.FIELD)
  @Retention(RetentionPolicy.RUNTIME)
  public @interface Constraints {
      boolean primaryKey() default false;
      boolean allowNull() default true;
      boolean unique() default false;
  }
  
  @Target(ElementType.FIELD)
  @Retention(RetentionPolicy.RUNTIME)
  public @interface SQLString {
      int value() default 0; // 在创建表的时候使用该值设置 SQL 列的大小。
      String name() default "";
      Constraints constrains() default @Constraints;
  }
  
  @Target(ElementType.FIELD)
  @Retention(RetentionPolicy.RUNTIME)
  public @interface SQLInteger {
      String name() default "";
      Constraints constraints() default @Constraints;
  }
  ```

  `Constraints`中的`primaryKey`、`allowNull`、`unique`提供了默认值，不需要使用者输入太多的信息。

  ` Constraints constraints() default @Constraints;`使用的是嵌套注解功能，将数据库列的类型约束信息嵌套其中；默认值采用的是注解`@Constraints`中定义的默认值。当然可以更改

  ```java
  public @interface Uniqueness {
       String name() default "";
      Constraints constraints()
              default @Constraints(unique = true);
  }
  ```

- 使用以上定义的注解

  ```java
  @DBTable(name = "MEMBER")
  public class Member {
      @SQLString(30)
      private String firstName;
      @SQLString(50)
      private String lastName;
      @SQLInteger
      private Integer age;
      @SQLString(value = 30,
              constrains = @Constraints(primaryKey = true))
      private String reference;
      private static int memberCount;
      public String getFirstName() {
          return firstName;
      }
      public String getLastName() {
          return lastName;
      }
      public Integer getAge() {
          return age;
      }
      public String getReference() {
          return reference;
      }
      @Override
      public String toString() {
          return reference;
      }
  }
  ```

  使用`@SQLString`和`@SQLString`的地方都默认使用了嵌入的`@Constraints`；如果注解中定义了名为**value**的元素，使用该注解时，**value**若为唯一一个需要赋值的元素，则赋值时可以省略**value**。如`@SQLString(30)`。

  上例中的 `@SQLString(value = 30,constrains = @Constraints(primaryKey = true))`还不能算清晰易懂。

- 注解处理器实现

  ```java
  public class TableCreator {
      public static void main(String[] args) throws ClassNotFoundException {
        if (args.length < 1) {
              System.out.println(
                      "arguments: annotated classes");
              System.exit(0);
          }
          for (String className : args) {
              Class<?> cl = Class.forName(className);
              DBTable dbTable = cl.getAnnotation(DBTable.class);
              if (dbTable == null) {
                  System.out.println(
                          "No DBTable annotations in class " +
                                  className);
                  continue;
              }
              String tableName = dbTable.name();
              if (tableName.length() < 1) {
                  tableName = cl.getName().toLowerCase();
              }
              ArrayList<String> columnDefs = new ArrayList<>();
              for (Field field : cl.getDeclaredFields()) {
                  String columnName = null;
                  Annotation[] anns = field.getDeclaredAnnotations();
                  if (anns[0] instanceof SQLInteger) {
                      SQLInteger sInt = (SQLInteger) anns[0];
                      if (sInt.name().length() < 1)
                          columnName = field.getName().toUpperCase();
                      else
                          columnName = sInt.name();
                      columnDefs.add(columnName + " INT" +
                              getConstraints(sInt.constraints()));
                  }
                  if (anns[0] instanceof SQLString) {
                      SQLString sString = (SQLString) anns[0];
                      // Use field name if name not specified.
                      if (sString.name().length() < 1)
                          columnName = field.getName().toUpperCase();
                      else
                          columnName = sString.name();
                      columnDefs.add(columnName + " VARCHAR(" +
                              sString.value() + ")" +
                              getConstraints(sString.constraints()));
                  }
              }
              StringBuilder createCommand = new StringBuilder(
                      "CREATE TABLE " + tableName + "(");
              for (String columnDef : columnDefs) {
                  createCommand.append("\n " + columnDef + ",");
              }
              String tableCreate = createCommand.substring(
                      0, createCommand.length() - 1) + ");";
              System.out.println("Table Creation SQL for " +
                      className + " is:\n" + tableCreate);
          }
      }
  
      private static String getConstraints(Constraints con) {
          String constraints = "";
          if (!con.allowNull()) {
              constraints +=" NOT NULL";
          }
          if (con.primaryKey()){
              constraints +=" PRIMARY KEY";
          }
          if (con.unique()) {
              constraints +=" UNIQUE";
          }
          return constraints;
      }
  
  }
  
  ```
  



## 一个最简单的处理器

- 编写一个只打印注解信息的处理器

  ```java
  @Retention(RetentionPolicy.SOURCE)
  @Target({ElementType.TYPE, ElementType.METHOD, ElementType.CONSTRUCTOR
          , ElementType.ANNOTATION_TYPE, ElementType.PACKAGE, ElementType.FIELD,
          ElementType.LOCAL_VARIABLE})
  public @interface Simple {
      String value() default "-default-";
  }
  @Simple
  public class SimpleTest {
      @Simple
      int i;
      @Simple
      public SimpleTest() {
      }
      @Simple
      public void foo(){
          System.out.println("SimpleTest.foo()");
      }
      @Simple
      public void bar(String s,int i,float f){
          System.out.println("SimpleTest.bar()");
      }
      @Simple
      public static void main(String[] args) {
          @Simple
          SimpleTest st = new SimpleTest();
          st.foo();
      }
  }
  @SupportedAnnotationTypes("com.chapter23.simpleprocessor.Simple")
  @SupportedSourceVersion(SourceVersion.RELEASE_8)
  public class SimpleProcessor extends AbstractProcessor {
      @Override
      public boolean process(Set<? extends TypeElement> annotations,
                             RoundEnvironment env) {
          for (TypeElement t : annotations) {
              System.out.println(t);
          }
          for (Element el : env.getElementsAnnotatedWith(Simple.class)) {
              display(el);
          }
          return false;
      }
  
      private void display(Element el) {
          System.out.println("=== " + el + " ===");
          System.out.println(el.getKind() +
                  " : " + el.getModifiers() +
                  " : " + el.getSimpleName() +
                  " : " + el.asType());
          if(el.getKind().equals(ElementKind.CLASS)) {
              TypeElement te = (TypeElement)el;
              System.out.println(te.getQualifiedName());
              System.out.println(te.getSuperclass());
              System.out.println(te.getEnclosedElements());
          }
          if(el.getKind().equals(ElementKind.METHOD)) {
              ExecutableElement ex = (ExecutableElement)el;
              System.out.print(ex.getReturnType() + " ");
              System.out.print(ex.getSimpleName() + "(");
              System.out.println(ex.getParameters() + ")");
          }
      }
  }
  // 编译脚本
  javac -processor com.chapter23.simpleprocessor.SimpleProcessor SimpleTest.java
  ```

  `@SupportedAnnotationTypes  `跟`@SupportedSourceVersion`这两个注解分别确定该类支持哪些注解，和支持的***java***版本。

## 基于注解的单元测试

